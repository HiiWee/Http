## [인터넷 네트워크 : IP(인터넷 프로토콜)]

* IP(인터넷 프로토콜) 역할
  * 지정한 IP 주소에 데이터 전살
  * 패킷(Packet)이라는 통신 단위로 데이터 전달

* IP 패킷 정보   
  * [클라이언트]
  * 전송데이터 외에 출발지IP, 목적지IP 및 메시지를 적어야 한다.
  * 이후 클라이언트는 패킷을 인터넷 망에 던진다.
  * 서로 노드끼리도 패킷 규약을 지키므로 결국 서버측으로 보내짐
  * [서버]
  * 출발지를 자신 목적지를 방금 받은 패킷의 IP, 내용은 잘 받았다는 내용으로 다시 클라이언트에게 보낸다.
* 요청, 응답시에 서로 다른 인터넷망으로 전달 될 수 도 있다.(하지만 목적지는 동일함)
* 하지만 이러한 IP 프로토콜 방식은 한계가 있다.
  * **비연결성**
    * 패킷 받을 대상 없고, 서비스 불능 상태여도 패킷 전송
  * **비신뢰성**
    * 중간에 패킷이 사라지면?
    * 패킷이 순서대로 안오면?(노드 장애, 다중 결로 라우팅과 같이 중간에 유실되거나 지연도착으로 인해 순서가 변경)
  * **프로그램 구분**
    * 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상 일 경우

> 이런 문제를 해결하는 방법이 TCP와 UDP가 있다.

<br><br>

## [인터넷 네트워크 : TCP, UDP]
* 인터넷 프로토콜 스택의 4계층
   
|인터넷 프로토콜 스택의 4계층|
|---------------------------|
|애플리케이션 계층 - HTTP, FTP|
|전송 계층 - TCP, UDP|
|인터넷 계층 - IP|
|네트워크 인터페이스 계층|

* TCP, UDP는 IP라는것에 위에 살짝 얹어서 보완해준다고 생각 좀 더 직관적으로

|||
|-|-|
|**애플리케이션**: |웹 브라우저, 네트워크 게임, 채팅 프로그램|
||[SOCKET 라이브러리]|
|**OS**: |[TCP] [UDP]]|
||IP(Internet Protocol|
|**네트워크 인터페이스**: |[LAN 드라이버, LAN 장비], LAN카드|

LAN 카드가 ---> 인터넷에 연결되고 ----> 서버로 보내짐

**[전송 순서]**   
1. 프로그램이 특정 메시지 생성
2. SOCKET 라이브러리를 통해 전달 (어플리케이션 계층)
3. TCP 정보 생성(패킷), 메시지 데이터 포함 (OS계층)
4. IP 패킷 생성, TCP 데이터 포함 (OS계층)
5. 이후 네트워크 인터페이스를 통해 LAN카드로 나감(이때 이더넷 프레임으로 감싸서 나가짐)

**[IP 패킷 정보]** :출발지 IP, 목적지 IP, 기타   
**[TCP/IP 패킷 정보]** : 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보   
<br>

### **[TCP의 특징]**   
전송 제어 프로토콜 (전송을 어떻게 할지 제어함)
* 연결지향 - TCP 3 way handshake(가상연결) : 연결을 하고 메시지를 보낸다.
* 데이터 전달 보증 : 패킷이 중간에 누락되면 보낸 클라이언트가 알 수 있음
* 순서 보장
> 따라서 TCP는 신뢰할 수 있고 대부분 TCP를 사용한다.

<br>

**TCP의 특징1 : TCP 3 way handshake**
1. SYN : 클라이언트에서 서버로 접속 요청 보냄
2. SYN + ACK(요청수락) : 서버도 수락과 동시에 클라이언트에 접속 요청을 보낸다.
3. ACK : 클라이언트는 요청을 수락한다. 
4. 이렇게 연결이 되고난 후 데이터가 전송된다.  
> ACK와 함꼐 메시지 전송 가능   
> 이렇게 하면 클라이언트와 서버가 서로를 믿을 수 있다.   
> 하지만 위 연결은 진짜로 연결된 것이 아니다.(개념적 연결)   
> 내부 서버들이 진짜로 연결됐는지는 모르고 서버와 클라이언트만 서로 연결됐다고 생각(논리적)

<br>   

**TCP의 특징2 : 데이터 전달 보증**
* TCP가 붙게 되면 서버로 데이터가 전송되면 데이터를 잘 받았다고 클라이언트로 메시지를 다시 보내줌

<br>

**TCP의 특징3 : 순서 보장**
1. 만약 패킷1, 패킷2, 패킷3 순서로 전송했을때
2. 서버에 패킷1, 패킷3, 패킷2 순서로 도착
3. 서버는 클라이언트에게 패킷2부터 다시 보내라고 클라이언트에 요청함

<br>

**이렇게 TCP의 특징들이 전부 가능한 이유는 TCP데이터 안에 전송제어, 순서, 검증 정보들이 포함되어 있기 때문이다. 따라서 TCP를 신뢰할 수 있는 프로토콜이라 말함**

<br>

### **[UDP의 특징]**   
사용자 데이터그램 프로토콜

* 하얀 도화지에 비유 (기능 거의 없음)
* 연결지향 - TCP 3 way handshake, 데이터 전달, 순서 보증 지원 안됨 따라서 단순하고 빠름
* IP와 거의 같지만 **PORT** 체크섬(메시지에 대해 올바른지 검증) 정도만 추가됨
> **PORT:** 하나의 IP에서 여러 애플리케이션을 이용할 때 여러 패킷이 이용되는데 이 때 각 패킷이 어떤 애플리케이션에서 이용되는 패킷인지 구분해주는 역할을 한다.   
> **UDP는 왜 쓸까?** : TCP는 3 way hs에서 시간이 많이 소요되고, 각종 데이터들의 양이 크므로 전송속도를 증가시키기 어렵다 이미 인터넷이 TCP기반이라 손을 댈 수 없다.   
> 따라서 더 최적화 하고 싶으면 TCP는 그대로 두고 UDP를 이용   
> UDP는 아무것도 없기 때문에 원하는것을 애플리케이션 레벨에서 만들면 된다. (요즘 각광 받음)

<br><br>

## [인터넷 네트워크 : PORT]
* 만약 한번에 둘 이상 연결해야 한다면 (게임, 화상통화, 웹 브라우저) 클라이언트 PC가 여러개의 서버와 통신해야 함
* 이때 각 서버에서 패킷들이 클라이언트로 날라오는데 어디에서 필요한 패킷인지 구분하기 힘듦
* TCP/IP 패킷 정보에는 출발지 PORT, 목적지 PORT가 존재한다.
  * **IP** : 목적지 서버를 찾거나, 출발지 클라이언트를 찾기 위함
  * **PORT** : 클라이언트 서버안에서 돌아가는 애플리케이션을 구분하기 위함
* 따라서 같은 IP내에서 프로세스를 구분하는것이 포트가 된다.
* 출발지 PORT, 목적지 PORT가 TCP 패킷에 존재하므로 서버로 요청할 때는 목적지 PORT를 이용하고,   
  반대로 서버에서 응답이 올때는 출발지 PORT를 이용해 응답이 온다.
  |웹 브라우저 요청 예시|출발지|목적지|
  |-|-|-|
  |IP|100.100.100.1|200.200.200.2|
  |PORT|10010|80|
  > 위와 같이 있을 때 브라우저 요청은 200.200.200.2:80으로 요청한다.   
  > 서버측은 브라우저를 100.100.100.1:10010으로 응답해 띄워준다.   
  > IP는 아파트 PORT는 몇동 몇호

<br><br>

## [인터넷 네트워크 : DNS]
* IP는 기억하기 어렵다는 문제가 있고, 변경될 수 있다.
  * 변경이 되면 접근을 할 수 없다.
* 따라서 DNS 도메인 네임 시스템을 이용한다.
  * 중간에 전화번호부 같은 서버를 제공한다.
  * 즉 도메인 명을 IP 주소로 변환한다.

  DNS 서버
  |도메인 명| IP|
  |-|-|
  |google.com|200.200.200.2|
  |aaa.com|210.210.210.3|
  > 이렇게 DNS 서버가 있을떄 어떻게 사용할까?   
  > 1. 클라이언트가 도메인 명으로 요청
  > 2. DNS서버가 응답으로 IP를 알려줌
  > 3. 받은 IP로 클라이언트는 서버로 접속한다.
  
<br><br>

## [URI와 웹 브라우저 요청 흐름 : URI]
**URI : Uniform Resource Identifier**   
URL는 로케이터(locator)와 이름(name)또는 둘 다 추가로 분류될 수 있다.

* URI는 주민번호처럼 자원 자체를 식별하는 방법이다.
* 여기에 크게 2가지가 있다.
  * URL(Resource Locator) : 리소스의 위치(거의 URL만 사용)
    > foo://example.com:8042/over/there?name=ferret#nose
  * URN(Resource Name) : 리소스의 이름
    > urn:example:animal:ferret:nose

* URI 단어의 뜻
  * Uniform : 리소스 식별하는 통일된 방식
  * Resource : 자원, URI로 식별할 수 있는 모든 것 (제한 없음)
  * Identifier: 다른 항목과 구분하는데 필요한 정보
  * URL의 Locator : 리소스가 있는 위치를 지정
  * URN의 Name : 리소스에 이름을 부여
  * 위치는 변할 수 있지만, 이름은 변하지 않음
  * URN이름만으로 실제 리소스 찾는 것은 보편화 되지 않음
  * 따라서 URI를 URL과 같은 의미로 이야기 함
<br><br>
* URL의 문법
  * sceme://[userinfo@]host[:port][/path][?query][#fragment]
  * https://www.google.com:443/search?q=hello&hl=ko
  
  * URL scheme
    * 프로토콜(https)
    * 주로 프로토콜(어떤 방식으로 자원에 접근하는지의 클라이언트 서버간 약속, 규칙) 사용 (예:http, https, ftp등)
    * http는 80, https 443 포트 사용(생략가능)
    * https는 https에 추가보안(HTTP secure)
  * URL userinfo
    * URL에 사용자 정보를 포함해 인증하지만 거의 사용하지 않음
  * URL host
    * 호스트명(www.google.com)
    * 도메인 명 또는 IP주소를 직접 사용 가능
  * URL PORT
    * 포트 번호(443)
    * 포트, 접속 포트(일반적으로 생략)
  * URL path
    * 패스(/search)
    * 리소스 경로, 계층적 구조
    * /home/file.jpg 혹은 /members/100과 같이 계층적
  * URL query
    * 쿼리 파라미터(q=hello&hl=ko)
    * key = value 형태
    * ?로 시작, &로 추가 가능(?keyA=valueA&keyB=valueB)
    * query parameter, query string 등으로 불림, 웹 서버에 제공하는 파라미터, 문자 형태임
  * URL fragment
    * html 내부 북마크 등에 사용
    * 서버에 전송하는 정보 아님

<br><br>

## [URI와 웹 브라우저 요청 흐름 : 웹 브라우저 요청 흐름]
https://www.google.com:443/search?q=hello&hl=ko 이렇게 보내게 되면   
먼저 DNS 조회를 한다 --> IP 추출(HTTPS PORT 생략, 443)   
1. 웹 브라우저가 HTTP 요청 메시지를 생성한다.
   * 메시지 내용 : `GET /search?q=hello&hi=ko HTTP/1.1 HOST: www.google.com`
2. SOCKET 라이브러리를 통해 전달
    - A: TCP/IP연결(IP, PORT)
    - B: 데이터 전달
3. TCP/IP 패킷 생성, HTTP 메시지 포함 이후 인터넷으로 흘러들어감

결국 출발지 IP and PORT, 목적지 IP and PORT, 전송데이터(웹브라우저가 만든 HTTP 요청 메시지)가 만들어짐   
이후 인터넷 망으로 요청 패킷 던져짐, 구글 서버는 요청 패킷을 받아서 TCP/IP는 버리고 HTTP 메시지를 받아서 분석하고 HTTP 응답 메시지를 만들고 TCP/IP로 씌워서 응답 패킷을 만들어 반환한다.
  * HTTP 응답 메시지
  > HTTP/1.1 200 OK   
  > Content-Type: text/html;charset=UTF-8(인코딩)   
  > Content-Length: 3423(실제 길이)   
  > -HTML코드-

이후 클라이언트가 응답 패킷의 HTTP 응답 메시지를 열면 html결과를 볼 수 있게 된다.


<br><br>

## [HTTP 기본 : 모든 것이 HTTP]
* HTTP - HyperText Transfer Protocol
* 모든 것이 HTTP - HTTP 메시지에 모든 것을 전송
  * HTML, TEXT
  * IMAGE, 음성, 영상, 파일
  * JSON, XML(API)
  * 거의 모든 형태의 데이터 전송 가능
  * 서버간 데이터를 주고 받을 때도 대부분 HTTP 사용함

* HTTP1.1을 가장 많이 사용
  * 대부분의 성능들이 이때 만들어짐

* 기반 프로토콜
  * TCP : HTTP/1.1, HTTP/2는 TCP프로토콜 위에서 동작함
  * UDP : HTTP/3는 UDP기반으로 만들어짐
  * 현재는 1.1을 주로 사용한다

* HTTP의 특징
  * 클라이언트-서버 구조로 동작함
  * 무상태 프로토콜(Stateless), 비연결성
  * HTTP메시지를 통해서 통신을 함(수신, 송신)
  * HTTP는 굉장히 단순하고 확장 가능하다.

> HTTP1.1에 현재 많이 사용하는 대부분의 기능들이 만들어졌다.   
> 2, 3는 1.1의 성능개선에 초점이 맞추어짐 따라서 1.1을 잘 알아야 한다.

<br><br>

## [HTTP 기본 : 클라이언트 서버 구조]
* Request Response 구조
* HTTP는 클라이언트가 HTTP메시지를 통햇 서버에 요청을 보낸다.   
  클라이언트는 서버의 응답이 올때까지 기다린다.   
  서버가 요청에 대한 결과를 만들어서 클라이언트에 응답하면 응답 결과를 열어서 클라이언트가 동작한다.
> 위와 같은 이유는 표면적인 이유다.   
> 이렇게 분리를 하는것이 매우 중요함 왜? 
> <br>  
> 클라이언트와 서버를 분리를 한 후 **비즈니스 로직, 데이터**들을 서버에 밀어 넣는다.   
> 이후 클라이언트는 바로 UI, 사용성에 집중을 한다.   
> 이렇게 되면 클라이언트, 서버가 각각 독립적으로 진화할 수 있다.
> <br>   
> **[클라이언트]** : 복잡한 비즈니스 로직, 데이터 제거 이후 단순하게 UI/UX만 어떻게 그릴지 집중할 수 있다.
> <br>   
> **[서버]** : 트래픽이 폭주하는 경우 클라이언트는 건드릴 필요 없이 서버측만 어떻게 더 고도화 하고 집중할 지 고민하면 된다.

## [HTTP 기본 : Stateful, Stateless]
### [HTTP의 중요한 특징 중 하나는 무상태 프로토콜을 지향한다. (Stateless)]
  * 서버가 클라이언트 상태를 보존하지 않음
    > 서버 확장성은 높으나(스케일 아웃) 클라이언트가 추가 데이터를 전송해야한다.

### [Stateful, less의 차이]
* Stateful(상태의 유지) : 서버가 클라이언트의 이전 상태를 보존(문맥 보존)
  * 한 점원이 결제하다 다른 점원으로 바뀌면 진행된 상황을 모르므로 문맥이 사라짐
* Stateless(상태를 유지하지 않음) : 문맥을 보존하지 않음 > **예시는 강의 참조**
  *  무상태는 애초에 클라이언트에서 모든 상황을 전부 제시하므로 점원이 바뀌어도 상관 없음

  > 결국 Stateful은 중간에 다른점원으로 바뀌면 안됨 (바뀌게 되면 상태정보를 바뀌는 점원에게 미리 알려야함)
  >    
  > stateless: 중간에 다른 점원으로 변경 가능   
  > * 갑자기 고객이 증가되도 점원 대거 투입 가능, 클라이언트 요청 증가해도 서버 대거 투입 가능해짐
  > * 결국 무상태는 응답 서버를 쉽게 바꿀 수 있다 -> **무한 서버 증설 가능**

* 무상태는 결국 스케일 아웃(수평확장)에 유리하다.

<br>

### [한계점]
1. 모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다.
   * 로그인은 상태유지 필요(일반적으로 브라우저 쿠키, 서버 세션을 사용함)
2. 데이터를 많이 보내야함 (요구 사항이 모호하지 않고 분명해야 하므로)
* 그렇다 하더라도 상태유지는 최소한만 사용해야 함(어쩔 수 없는 경우에만)

<br><br>

## [HTTP 기본 : 비 연결성(connectionless)]
* 클라이언트가 3개가 있고 서버에 각각 연결했을때   
  서버 1개가 요청을 해도 다른 2개가 연결되어 있는 상태면 요청이 없어도 서버 자원이 계속 사용된다. (Request, Response 객체 생성 등)

* 따라서 연결을 유지하지 않아야함
  * TCP/IP를 연결하고 요청을 서버가 받으면 즉시 연결을 끊음(필요한것만 주고받고 연결 끊음)
  * 이렇게 되면 서버 입장에서는 요청을 주고받을때만 연결을 하므로 서버가 유지하는 자원 최소화 할 수 있다.
  
### [비 연결성]
**장점**   
* HTTP는 기본이 연결을 유지하지 않는 모델
* 일반적으로 초 단위 이하의 빠른속도로 응답
* 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시 처리 요청은 수십개 이하로 적다
  * 웹 브라우저에서 계속 연속적으로 버튼을 누르지 않기 때문임
* 즉 비연결성은 서버 자원의 효율적 사용 가능   

**단점**   
*  TCP/IP 연결 새로 맺어야 함(3 Way handshake)
*  사이트 요청시 HTML, JS, CSS, 이미지 등 많은 자원 다운로드
*  현재는 HTTP지속 연결(Persistent Connections)로 문제를 해결함
*  HTTP/2, HTTP/3에서 더 많은 최적화가 이루어 졌다.
> 초기 HTTP 연결 종료에서의 낭비는 강의자료 참조)

### STATELESS를 기억
### 서버 개발자들이 어려워하는 업무

* 같은 시간에 딱 맞추어 발생하는 대용량 트래픽
  * KTX예약, 선착순 이벤트, 학과 수업 등록
* 최대한 STATELESS하게 만들면 대용량 트래픽이 와도 서버를 순간 늘려서 대응할 수 있게 한다.
  * 첫 페이지는 정적페이지를 두고 이후 이벤트 참여 버튼을 눌러 딜레이를 만든다.

<br><br>

## [HTTP 기본 : HTTP 메시지]
  
### HTTP 메시지에 모든 것을 전송

* HTTP의 요청 메시지와 응답 메시지는 구조가 약간 다름
* HTTP 메시지 구조   
  |HTTP 메시지 구조|
  |---------------------------|
  |start-line 시작라인|
  |header 헤더|
  |empty line 공백 라인 (CRLF)|
  |message body|

  |HTTP 요청 메시지|
  |---------------------------|
  |GET /search?q=helloA&hi=ko HTTP/1.1|
  |Host: www.google.com|
  | -공백- (요청 메시지도 body 본문 가질 수 있음)|

  |HTTP 응답 메시지|
  |---------------------------|
  |HTTP/1.1 200 OK(여기서 OK는 사람이 읽을 수 있게 짧게 표기)|
  |Content-Type: text/heml;charset=UTF-8 <br> Context-Length: 3423|
  | -공백- |
  |\<html>html 내용\</html>|

### [시작라인 (요청 메시지)]
* **request-line**, status-line으로 나뉨 (요청 메시지는 request-line)
* **request-line** = **method**(GET, POST등) SP(Space) **request-target**(path들어감) SP **HTTP-version** CRLF(엔터)
  1. HTTP 메서드
      * 종류 : GET, POST, PUT, DELETE
      * 서버가 수행할 동작 지정
        * GET : 리소스 조회
        * POST : 요청 내역 처리
  2. 요청 대상
      * 절대경로로 작성(/로 시작)
      * 다른 유형도 있지만 절대경로를 기억
  3. HTTP 버전

### [시작라인 (응답 메시지)]
* **start-line** = **HTTP-version** SP **status-code(상태코드 성공 실패 여부)** SP **reason-phrase** CRLF
  1. HTTP 버전
  2. HTTP 상태 코드: 요청 성공, 실패 알려줌
      * 200=성공, 400=클라이언트 요청 오류, 500=서버 내부 오류
  3. 이유 문구: 사람이 이해하는 짧은 문장
   
### [HTTP 헤더]
* header-field - field-name":" OWS field-value OWS (OWS: 띄어쓰기 허용)
  * field-name은 대소문자 구분 없다 하지만, value는 구분함
* 용도 : HTTP 전송에 필요한 모든 부가정보 가짐(내용, 크기, 압축, 인증, 요청 등 body제외 필요한 메타이데터 정보 들어감)
* 표준 헤더는 매우 많음

### [HTTP 메시지 바디]
* 실제 전송할 데이터
* byte로 표현할 수 있는 모든 데이터 전송 가능(HTML, 이미지, 영상, JSON등)


### [HTTP == 단순함, 확장 가능 (크게 성공하는 기술 == 단순하지만 확장 가능한 기술)]

<br><br>

## [HTTP 메서드 : HTTP API를 만들어보자]
* 회원정보관리 api를 만들려고 할 때 나오는 동작들은
  * 회원 목록 조회, 회원 조회, 회원 등록, 회원 수정, 회원 삭제 등이 있다.

* 그렇다면 API URI를 설계 할 때 위의 동작들을 모두 각각 URI로 설계해야 할까?
  * 좋지 못한 설계 URI의 설계 기준은 리소스다.
* **URI설계에서 가장 중요한 것은 리소스를 식별하는 것이다.** 
  * 리소스의 의미 : 회원 등록, 조회, 수정, 삭제 등 동작이 기준이 아닌 **회원이라는 개념 자체**
  * 리소스 식별 방법 : 회원에 관한 동적 행위들은 모두 배제 후 회원이라는 리소스만 식별한다.   
    **회원이라는 리소스만 식별하면 됨 -> 회원 리소스를 URI에 매핑**

### 리소스를 식별한 API URI설계
  * 회원 목록 조회 /members
  * 회원 조회 /members/{id}
  * 회원 등록 /members/{id}
  * 회원 수정 /members/{id}
  * 회원 삭제 /members/{id}
  > 계층 구조상 상위를 컬렉션으로 보고 **복수 단어**를 사용하길 권장함
  
  <br>

  * 위와 같은 구조에서 각각의 동작(수정, 조회, 삭제 등)들을 구분하는 방법?
    * 보기에는 모두 같은 URI가 매칭됐다. 이걸 어떻게 구분하여 동작시킬까?
    * 리소스 == 명사, 행위 == 동사
    * URI는 리소스(명사)를 식별하는데만 사용된다.
    * 따라서 리소스와 해당 리소스를 대상으로 하는 **행위**로 분리한다.
      * 리소스 : 회원
      * 행위 : 조회, 등록, 수정, 삭제 등
    * 리소스의 행위(동사)는 **HTTP method (GET, POST, PUT, DELETE)** 를 이용해 구분

<br><br>

## [HTTP 메서드 : GET, POST]
HTTP  메서드는 클라이언트가 서버에 무엇인가를 요청을 할 때 기대하는 행동   
**GET**:  무엇인가를 달라고 요청   
**POST** : 데이터를 줄테니 등록 혹은 처리를 해달라는 요청

### 주요 메서드
1. GET : 리소스 조회
2. POST : 요청 데이터 처리, 주로 등록에 사용
3. PUT : 클라이언트 - 서버로 리소스를 보내는데 이 리소스로 대체, 해당 리소스가 없으면 생성
4. PATCH : 리소스의 부분 변경 (이름, 특정 필드 등)
5. DELETE : 리소스 삭제
6. HEAD : GET과 동일하지만 메시지 부분을 제외하고 , 상태줄과 헤더만 반환
7. OPTIONS : CORS서 주로 사용 대상 리소스에 대한 통신 가능 옵션을 설명

### GET
**리소스 조회가 주 목적 **  
서버에 전달하고 싶은 데이터 query를 통해 전달(쿼리 스트링, 쿼리 파라미터)   
메시지 바디를 사용해서 데이터 전달가능하지만, 지원 하지 않는곳 많아 실무에선 사용하지 않음   
<br>

**GET 동작 예시**   
1. 클라이언트가 GET /members/100 HTTP/1.1로 요청을 보내면

2. 서버에서 메시지를 열어보고 DB조회 후 JSON(다른것도가능)형태로 만들고 응답 메시지를 만들어서 클라이언트로 보낸다.

3. 이후 클라이언트에선 이 메시지를 가지고 이용할것이다. 
> (그림은 강의자료 참조)

### POST
클라이언트에서 서버로 요청을 보낼때 특정 데이터를 줌   
서버는 이를 받아서 **요청 데이터를 처리**  
즉 메시지 바디를 통해 서버로 요청 데이터 전달   
서버는 요청 데이터를 처리 (메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.)   
주로 전달된 데이터로 **신규 리소스 등록**, **프로세스 처리**에 사용함
<br>

**POST 동작 예시**
* 클라이언트가 서버로 
  ```
  POST / members HTTP/1.1
  Content-Type: application/json
  {
    "username": "young",
    "age": 20
  }
  ```
  위와 같은 메시지를 /members로 전달

* 이 때 약속을 해야함   
  (클라이언트가 /members에 post로 보내면 그 데이터는 내가 저장할지, 내부적 프로세스에 사용할것인지 미리 약속함 여기서는 신규등록으로 가정)

* 서버는 메시지를 받아 열어보고 데이터를 가지고 신규 등록(DB)을 한다.

* 이후 신규 아이디를 만들어서 신규 리소스 식별자 생성을 함(예시로 100)

* 이후 응답 데이터를 보낸다. **HTTP/1.1 201 Created**

* 200도 가능 201로 보내면 Location을 보냄 이는 자원이 생성된 PATH를 보내준다.
* 또한 기본적으로 등록된 자원에 대한 데이터도 보낸다.

<br>

### POST는 요청 데이터를 어떻게 처리한다는 뜻일까?

**스펙** : POST메서드는 대상 리소스가 리소스의 고유한 의미 체계에 따라 요청에 포함 된 표현을 처리하도록 요청합니다.

* HTML 양식에 입력 된 **필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공**(HTML FORM)   
게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시(게시판 글쓰기, 댓글 달기)

* 서버가 아직 식별하지 않은 **새 리소스 생성** (신규 주문 생성)

* 기존 자원에 **데이터 추가** (한 문서 끝에 내용 추가)

**정리** : 리소스 URI에 POST요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 한다.

### POST 정리

1. 새 리소스 생성(등록) : 서버가 아직 식별하지 않은 새 리소스 생성

2. 요청 데이터 처리 : 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 프로세스를 처리해야 하는 경우

    >  **예)** : 주문에서 결제완료 -> 배달시작 -> 배달완료 처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우   
    > 즉 POST의 결과로 새로운 리소스가 생성되지 않을 수 도 있다.   

    > **예)** POST/ orders/{orderId}/start-delivery (**컨트롤 URI**)   
      위와 같이 동사의 URI가 나올 수 도 있고 이를 컨트롤 URI라함   
      (리소스로 모든것을 설계할 수 없는 부분도 있다)

3. 다른 메서드로 처리하기 애매한 경우

    > **예)** JSON으로 조회 데이터를 넘기는데, GET메서드를 사용하기 어려운 경우(GET메소드의 메시지 바디를 지원하지 않는 서버가 많음)

    > **예)** 애매하면 POST! (POST는 모든것을 할 수 있다.)   
    (하지만 조회할때는 GET이 유리 예를 들어서버끼리는 약속을 함 GET 요청이 오면 캐싱을 하겠다. 하지만 POST는 캐싱을하기 어려움    
    따라서 조회의 데이터는 최대한 GET을 사용하자)
    
<br><br>

## [HTTP 메서드 : PUT, PATCH, DELETE]

### PUT
* 리소스를 **완전히** 대체
  * 리소스가 있으면 대체, 없으면 생성 (쉽게 이야기해서 덮어버림)
  * 아래와 같은 상황에서 100번 리소스 있으면 신규생성, 있으면 완전히 새로 대체
    ```
    PUT /members/100 HTTP/1.1
    Content-Type: application/json
    {
      "username": "hello",
      "age": 20
    }
    ```
* **중요! 클라이언트가 리소스를 식별**
  * 클라이언트가 리소스 위치를 알고 URI를 지정함
    * /members/100 리소스의 위치를 알고 구체적으로 지정
  * 이것에서 POST와 큰 차이를 보인다.(POST는 100인지 101인지 모르고 /members를 호출)
  > PUT은 두가지를 기억하자
  > 1. 리소스를 대체한다.
  > 2. 클라이언트가 리소스를 알고있어야 한다.

<br>

**PUT 동작 예시**
1. 리소스가 있는 경우
   * 클라이언트에서 보내는 메시지
      ```
      PUT /members/100 HTTP/1.1
      Content-Type: application/json
      {
        "username": "old",
        "age": 50
      }
      ```
   * 만약 기존 /members/100에 username : young, age : 20이라는 리소스가 있었다면
   * 새로 들어온 값으로 대체한다.

2. 리소스가 없는 경우
   * 리소스가 없으면 서버에서 신규 리소스가 생성된다.
*  **리소스를 완전히 대체한다를 알아두자!!**
   *  만약 클라이언트에서 username을 빼고 age필드만 변경하고 서버로 전송해도 username필드가 삭제된다.
   *  왜? 완전히 대체하므로!!
   *  PUT은 리소스의 수정이 아닌 완전히 갈아치우는 것
*  리소스의 수정의도로 사용하기 위해선 PATCH를 사용하면 된다.

<br>

### PATCH : 리소스 부분 변경
* 만약 PATCH로 age : 50만 보내면 기존 username은 날리지 않고 age필드만 부분변경된다.
  * 부분 변경을 위해서는 PATCH를 사용하자

<br>

### DELETE : 리소스를 제거
* DELETE /members/100 HTTP/1.1 이렇게 클라이언트가 서버로 메시지를 보내면
* 서버측이 /members/100을 보고 100을 제거한다.

<br>

### **정리**   
> PUT 완전히 대체, PATCH 부분 변경, DELETE 제거이다.   
> 리소스를 부분변경할떄는 PATCH를 사용할 수 있지만 지원 하지 않는 서버도 존재
> 그런 경우에는 POST를 사용하자

<br><br>

## [HTTP 메서드 : HTTP 메서드의 속성]
* 안전(Safe Methods)
* 멱등(Idempotent Methods)
* 캐시가능(Cacheable Methods)
> HTTP 메서드별 속성 정리 표 : https://ko.wikipedia.org/wiki/HTTP

### 안전(Safe)
* 호출해도 리소스를 변경하지 않음
* 호출할 때 오류가 발생하는것과 같이 외부적인 장애는 고려하지 않음
* 단지 특정 메소드가 특정 리소스를 변경하는지 여부만 고려한다.

### 멱등(Idempotante)
* f(f(x)) = f(x)
* 한 번 호출하던, 100번 호출하던 결과는 동일하다.
* 멱등 메소드
  * GET: 여러번 조회해도 동일한 결과
  * PUT: 결과를 대체한다. 하지만 동일한 요청일때 동일한 결과를 반환하므로 멱등
  * DELETE: 결과를 삭제한다. 여러번의 동일요청있을때 동일결과를 반환하므로 멱등
  > POST는 멱등이 아니다 -> 결제 요청을 두 번 한다면 두 번의 결제가 중복되어 발생할 수 있다.
* 멱등 활용
  * 자동 복구 메커니즘
  * 서버가 TIMEOUT등 특정 문제로 인해 정상 응답을 하지 못한 경우, 클라이언트가 동일 요처을   
    다시 해도 되는가의 근거가 된다.

> **[의문]** 요청 중간에 다른 사용자의 요청으로 리소스가 변경된 경우 멱등성은 지켜지는가?   
> -> 멱등은 외부 요인으로 중간에 리소스가 변경되는 부분은 고려하지 않음

### 캐시가능(Cacheable)
* 응답 결과 리소스를 캐시하여 사용해도 되는지의 여부
* GET, HEAD, POST, PATCH 캐시가능
* 하지만 실제로는 GET, HEAD정도만 캐시로 사용한다.
  * POST, PATCH는 본문(BODY)내용까지 캐시 키로 고려해야 하므로 구현 어려움

<br><br>

## [HTTP 메서드 활용 : 클라이언트에서 서버로 데이터 전송]

### 크게 2가지의 데이터 전달 방식 존재
1. 쿼리 파라미터를 통한 데이터 전송
    * GET
    * 주로 정렬 필터(검색어로 검색할때, 게시판 리스트에 정렬조건 넣을때)
2. 메시지 바디를 통한 데이터 전송
    * POST, PUT, PATCH
    * 회원가입, 상품 주문, 리소스 등록, 리소스 변경과 같은 경우 주로 사용한다.

### 4가지 상황의 클라이언트->서버 데이터 전송 방법
1. 정적 데이터 조회
    * IMG, 정적 텍스트 문서
2. 동적 데이터 조회
    * 주로 검색, 게시판 목록 정렬 필터(검색어)
3. HTML Form을 통한 데이터 전송
    * 회원 가입, 상품 주문, 데이터 변경
4. HTTP API를 통한 데이터 전송
    * 회원 가입, 상품 주문, 데이터 변경
    * 서버 to 서버, 앱 클라이언트, 웹 클라이언트(Ajax)

### 1. 정적 데이터 조회(쿼리 파라미터 미사용)
* 쿼리 파라미터 없이 리소스 경로로 단순하게 조회 가능하다. (GET 방식)

### 2. 동적 데이터 조회(쿼리 파라미터 사용)
* https://www.google.com/search?**q=hello&hi=ko**
* 위의 URL을 서버에 요청하면 서버는 쿼리 파라미터 기반으로 정렬 필터해서 결과를 동적으로 생성한다.
* 주로 조회 조건을 줄여주는 필터, 조회 결과 정렬하는 정렬 조건에 사용된다.
* 조회는 GET방식(쿼리 파라미터 이용하여 데이터 전달)

### 3. HTML Form 데이터 전송(POST 전송 - 저장)
``` html
  <form action="/save" method="post">
  </form>
```
* HTML Form submit시 POST 전송
  * 예) 회원가입, 상품주문, 데이터 변경 등
* Content-type: application/x-www-form-urlencoded 사용
  * form내용 메시지 바디 통해 전송 (key=value 형식으로 -> 쿼리 파라미터 형석)
  * 전송 데이터를 url encoding 처리 (한글 -> UTF-8과 같이 변경)
* HTML Form은 POST 및 GET 전송도 가능하다.(하지만, GET은 데이터를 저장하는 용도로 사용하면 안됨)
* Content-Type: multipart/form-data
  ``` html
  <form action="/save" method="post" enctype="multipart/form-data">
  </form>
  ```
  * 파일 업로드와 같은 바이너리 데이터도 전송 가능하다.
  * 다른 종류의 여러 파일과 폼의 내용을 함께 전달 가능(multi-part)
> HTML Form 전송은 GET, POST만 지원한다.

### 4. HTTP API 데이터 전송
* 그냥 직접 API를 만들면 된다. (클라이언트 라이브러리를 보통 이용)
```
POST/ members HTTP/1.1
Content-Type: application/json

{
  "username": "young",
  "age": 20
}
```
* 서버 to 서버
  * 백엔드 시스템 끼리의 통신
* 앱 클라이언트 (아이폰, 안드로이드)
* 웹 클라이언트
  * HTML에서 Form 전송 대신 자바스크립트를 통한 통신에 사용(AJAX)
  * 예) React, VueJs 같은 웹 클라이언트와 API 통신
* POST, PATCH, PUT: 메시지 바디를 통해 데이터 전송
* GET: 조회, 쿼리 파라미터로 데이터 전송
* Content-Type은 application/json을 주로 사용 (사실상 표준)
  * 외에도 XML, TEXT도 가능