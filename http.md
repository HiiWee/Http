## [인터넷 네트워크 : IP(인터넷 프로토콜)]

* IP(인터넷 프로토콜) 역할
  * 지정한 IP 주소에 데이터 전살
  * 패킷(Packet)이라는 통신 단위로 데이터 전달

* IP 패킷 정보   
  * [클라이언트]
  * 전송데이터 외에 출발지IP, 목적지IP 및 메시지를 적어야 한다.
  * 이후 클라이언트는 패킷을 인터넷 망에 던진다.
  * 서로 노드끼리도 패킷 규약을 지키므로 결국 서버측으로 보내짐
  * [서버]
  * 출발지를 자신 목적지를 방금 받은 패킷의 IP, 내용은 잘 받았다는 내용으로 다시 클라이언트에게 보낸다.
* 요청, 응답시에 서로 다른 인터넷망으로 전달 될 수 도 있다.(하지만 목적지는 동일함)
* 하지만 이러한 IP 프로토콜 방식은 한계가 있다.
  * **비연결성**
    * 패킷 받을 대상 없고, 서비스 불능 상태여도 패킷 전송
  * **비신뢰성**
    * 중간에 패킷이 사라지면?
    * 패킷이 순서대로 안오면?(노드 장애, 다중 결로 라우팅과 같이 중간에 유실되거나 지연도착으로 인해 순서가 변경)
  * **프로그램 구분**
    * 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상 일 경우

> 이런 문제를 해결하는 방법이 TCP와 UDP가 있다.

<br><br>

## [인터넷 네트워크 : TCP, UDP]
* 인터넷 프로토콜 스택의 4계층
   
|인터넷 프로토콜 스택의 4계층|
|---------------------------|
|애플리케이션 계층 - HTTP, FTP|
|전송 계층 - TCP, UDP|
|인터넷 계층 - IP|
|네트워크 인터페이스 계층|

* TCP, UDP는 IP라는것에 위에 살짝 얹어서 보완해준다고 생각 좀 더 직관적으로

|||
|-|-|
|**애플리케이션**: |웹 브라우저, 네트워크 게임, 채팅 프로그램|
||[SOCKET 라이브러리]|
|**OS**: |[TCP] [UDP]]|
||IP(Internet Protocol|
|**네트워크 인터페이스**: |[LAN 드라이버, LAN 장비], LAN카드|

LAN 카드가 ---> 인터넷에 연결되고 ----> 서버로 보내짐

**[전송 순서]**   
1. 프로그램이 특정 메시지 생성
2. SOCKET 라이브러리를 통해 전달 (어플리케이션 계층)
3. TCP 정보 생성(패킷), 메시지 데이터 포함 (OS계층)
4. IP 패킷 생성, TCP 데이터 포함 (OS계층)
5. 이후 네트워크 인터페이스를 통해 LAN카드로 나감(이때 이더넷 프레임으로 감싸서 나가짐)

**[IP 패킷 정보]** :출발지 IP, 목적지 IP, 기타   
**[TCP/IP 패킷 정보]** : 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보   
<br>

### **[TCP의 특징]**   
전송 제어 프로토콜 (전송을 어떻게 할지 제어함)
* 연결지향 - TCP 3 way handshake(가상연결) : 연결을 하고 메시지를 보낸다.
* 데이터 전달 보증 : 패킷이 중간에 누락되면 보낸 클라이언트가 알 수 있음
* 순서 보장
> 따라서 TCP는 신뢰할 수 있고 대부분 TCP를 사용한다.

<br>

**TCP의 특징1 : TCP 3 way handshake**
1. SYN : 클라이언트에서 서버로 접속 요청 보냄
2. SYN + ACK(요청수락) : 서버도 수락과 동시에 클라이언트에 접속 요청을 보낸다.
3. ACK : 클라이언트는 요청을 수락한다. 
4. 이렇게 연결이 되고난 후 데이터가 전송된다.  
> ACK와 함꼐 메시지 전송 가능   
> 이렇게 하면 클라이언트와 서버가 서로를 믿을 수 있다.   
> 하지만 위 연결은 진짜로 연결된 것이 아니다.(개념적 연결)   
> 내부 서버들이 진짜로 연결됐는지는 모르고 서버와 클라이언트만 서로 연결됐다고 생각(논리적)

<br>   

**TCP의 특징2 : 데이터 전달 보증**
* TCP가 붙게 되면 서버로 데이터가 전송되면 데이터를 잘 받았다고 클라이언트로 메시지를 다시 보내줌

<br>

**TCP의 특징3 : 순서 보장**
1. 만약 패킷1, 패킷2, 패킷3 순서로 전송했을때
2. 서버에 패킷1, 패킷3, 패킷2 순서로 도착
3. 서버는 클라이언트에게 패킷2부터 다시 보내라고 클라이언트에 요청함

<br>

**이렇게 TCP의 특징들이 전부 가능한 이유는 TCP데이터 안에 전송제어, 순서, 검증 정보들이 포함되어 있기 때문이다. 따라서 TCP를 신뢰할 수 있는 프로토콜이라 말함**

<br>

### **[UDP의 특징]**   
사용자 데이터그램 프로토콜

* 하얀 도화지에 비유 (기능 거의 없음)
* 연결지향 - TCP 3 way handshake, 데이터 전달, 순서 보증 지원 안됨 따라서 단순하고 빠름
* IP와 거의 같지만 **PORT** 체크섬(메시지에 대해 올바른지 검증) 정도만 추가됨
> **PORT:** 하나의 IP에서 여러 애플리케이션을 이용할 때 여러 패킷이 이용되는데 이 때 각 패킷이 어떤 애플리케이션에서 이용되는 패킷인지 구분해주는 역할을 한다.   
> **UDP는 왜 쓸까?** : TCP는 3 way hs에서 시간이 많이 소요되고, 각종 데이터들의 양이 크므로 전송속도를 증가시키기 어렵다 이미 인터넷이 TCP기반이라 손을 댈 수 없다.   
> 따라서 더 최적화 하고 싶으면 TCP는 그대로 두고 UDP를 이용   
> UDP는 아무것도 없기 때문에 원하는것을 애플리케이션 레벨에서 만들면 된다. (요즘 각광 받음)

<br><br>

## [인터넷 네트워크 : PORT]
* 만약 한번에 둘 이상 연결해야 한다면 (게임, 화상통화, 웹 브라우저) 클라이언트 PC가 여러개의 서버와 통신해야 함
* 이때 각 서버에서 패킷들이 클라이언트로 날라오는데 어디에서 필요한 패킷인지 구분하기 힘듦
* TCP/IP 패킷 정보에는 출발지 PORT, 목적지 PORT가 존재한다.
  * **IP** : 목적지 서버를 찾거나, 출발지 클라이언트를 찾기 위함
  * **PORT** : 클라이언트 서버안에서 돌아가는 애플리케이션을 구분하기 위함
* 따라서 같은 IP내에서 프로세스를 구분하는것이 포트가 된다.
* 출발지 PORT, 목적지 PORT가 TCP 패킷에 존재하므로 서버로 요청할 때는 목적지 PORT를 이용하고,   
  반대로 서버에서 응답이 올때는 출발지 PORT를 이용해 응답이 온다.
  |웹 브라우저 요청 예시|출발지|목적지|
  |-|-|-|
  |IP|100.100.100.1|200.200.200.2|
  |PORT|10010|80|
  > 위와 같이 있을 때 브라우저 요청은 200.200.200.2:80으로 요청한다.   
  > 서버측은 브라우저를 100.100.100.1:10010으로 응답해 띄워준다.   
  > IP는 아파트 PORT는 몇동 몇호

<br><br>

## [인터넷 네트워크 : DNS]
* IP는 기억하기 어렵다는 문제가 있고, 변경될 수 있다.
  * 변경이 되면 접근을 할 수 없다.
* 따라서 DNS 도메인 네임 시스템을 이용한다.
  * 중간에 전화번호부 같은 서버를 제공한다.
  * 즉 도메인 명을 IP 주소로 변환한다.

  DNS 서버
  |도메인 명| IP|
  |-|-|
  |google.com|200.200.200.2|
  |aaa.com|210.210.210.3|
  > 이렇게 DNS 서버가 있을떄 어떻게 사용할까?   
  > 1. 클라이언트가 도메인 명으로 요청
  > 2. DNS서버가 응답으로 IP를 알려줌
  > 3. 받은 IP로 클라이언트는 서버로 접속한다.
  
<br><br>

## [URI와 웹 브라우저 요청 흐름 : URI]
**URI : Uniform Resource Identifier**   
URL는 로케이터(locator)와 이름(name)또는 둘 다 추가로 분류될 수 있다.

* URI는 주민번호처럼 자원 자체를 식별하는 방법이다.
* 여기에 크게 2가지가 있다.
  * URL(Resource Locator) : 리소스의 위치(거의 URL만 사용)
    > foo://example.com:8042/over/there?name=ferret#nose
  * URN(Resource Name) : 리소스의 이름
    > urn:example:animal:ferret:nose

* URI 단어의 뜻
  * Uniform : 리소스 식별하는 통일된 방식
  * Resource : 자원, URI로 식별할 수 있는 모든 것 (제한 없음)
  * Identifier: 다른 항목과 구분하는데 필요한 정보
  * URL의 Locator : 리소스가 있는 위치를 지정
  * URN의 Name : 리소스에 이름을 부여
  * 위치는 변할 수 있지만, 이름은 변하지 않음
  * URN이름만으로 실제 리소스 찾는 것은 보편화 되지 않음
  * 따라서 URI를 URL과 같은 의미로 이야기 함
<br><br>
* URL의 문법
  * sceme://[userinfo@]host[:port][/path][?query][#fragment]
  * https://www.google.com:443/search?q=hello&hl=ko
  
  * URL scheme
    * 프로토콜(https)
    * 주로 프로토콜(어떤 방식으로 자원에 접근하는지의 클라이언트 서버간 약속, 규칙) 사용 (예:http, https, ftp등)
    * http는 80, https 443 포트 사용(생략가능)
    * https는 https에 추가보안(HTTP secure)
  * URL userinfo
    * URL에 사용자 정보를 포함해 인증하지만 거의 사용하지 않음
  * URL host
    * 호스트명(www.google.com)
    * 도메인 명 또는 IP주소를 직접 사용 가능
  * URL PORT
    * 포트 번호(443)
    * 포트, 접속 포트(일반적으로 생략)
  * URL path
    * 패스(/search)
    * 리소스 경로, 계층적 구조
    * /home/file.jpg 혹은 /members/100과 같이 계층적
  * URL query
    * 쿼리 파라미터(q=hello&hl=ko)
    * key = value 형태
    * ?로 시작, &로 추가 가능(?keyA=valueA&keyB=valueB)
    * query parameter, query string 등으로 불림, 웹 서버에 제공하는 파라미터, 문자 형태임
  * URL fragment
    * html 내부 북마크 등에 사용
    * 서버에 전송하는 정보 아님

<br><br>

## [URI와 웹 브라우저 요청 흐름 : 웹 브라우저 요청 흐름]
https://www.google.com:443/search?q=hello&hl=ko 이렇게 보내게 되면   
먼저 DNS 조회를 한다 --> IP 추출(HTTPS PORT 생략, 443)   
1. 웹 브라우저가 HTTP 요청 메시지를 생성한다.
   * 메시지 내용 : `GET /search?q=hello&hi=ko HTTP/1.1 HOST: www.google.com`
2. SOCKET 라이브러리를 통해 전달
    - A: TCP/IP연결(IP, PORT)
    - B: 데이터 전달
3. TCP/IP 패킷 생성, HTTP 메시지 포함 이후 인터넷으로 흘러들어감

결국 출발지 IP and PORT, 목적지 IP and PORT, 전송데이터(웹브라우저가 만든 HTTP 요청 메시지)가 만들어짐   
이후 인터넷 망으로 요청 패킷 던져짐, 구글 서버는 요청 패킷을 받아서 TCP/IP는 버리고 HTTP 메시지를 받아서 분석하고 HTTP 응답 메시지를 만들고 TCP/IP로 씌워서 응답 패킷을 만들어 반환한다.
  * HTTP 응답 메시지
  > HTTP/1.1 200 OK   
  > Content-Type: text/html;charset=UTF-8(인코딩)   
  > Content-Length: 3423(실제 길이)   
  > -HTML코드-

이후 클라이언트가 응답 패킷의 HTTP 응답 메시지를 열면 html결과를 볼 수 있게 된다.


<br><br>

## [HTTP 기본 : 모든 것이 HTTP]
* HTTP - HyperText Transfer Protocol
* 모든 것이 HTTP - HTTP 메시지에 모든 것을 전송
  * HTML, TEXT
  * IMAGE, 음성, 영상, 파일
  * JSON, XML(API)
  * 거의 모든 형태의 데이터 전송 가능
  * 서버간 데이터를 주고 받을 때도 대부분 HTTP 사용함

* HTTP1.1을 가장 많이 사용
  * 대부분의 성능들이 이때 만들어짐

* 기반 프로토콜
  * TCP : HTTP/1.1, HTTP/2는 TCP프로토콜 위에서 동작함
  * UDP : HTTP/3는 UDP기반으로 만들어짐
  * 현재는 1.1을 주로 사용한다

* HTTP의 특징
  * 클라이언트-서버 구조로 동작함
  * 무상태 프로토콜(Stateless), 비연결성
  * HTTP메시지를 통해서 통신을 함(수신, 송신)
  * HTTP는 굉장히 단순하고 확장 가능하다.

> HTTP1.1에 현재 많이 사용하는 대부분의 기능들이 만들어졌다.   
> 2, 3는 1.1의 성능개선에 초점이 맞추어짐 따라서 1.1을 잘 알아야 한다.

<br><br>

## [HTTP 기본 : 클라이언트 서버 구조]
* Request Response 구조
* HTTP는 클라이언트가 HTTP메시지를 통햇 서버에 요청을 보낸다.   
  클라이언트는 서버의 응답이 올때까지 기다린다.   
  서버가 요청에 대한 결과를 만들어서 클라이언트에 응답하면 응답 결과를 열어서 클라이언트가 동작한다.
> 위와 같은 이유는 표면적인 이유다.   
> 이렇게 분리를 하는것이 매우 중요함 왜? 
> <br>  
> 클라이언트와 서버를 분리를 한 후 **비즈니스 로직, 데이터**들을 서버에 밀어 넣는다.   
> 이후 클라이언트는 바로 UI, 사용성에 집중을 한다.   
> 이렇게 되면 클라이언트, 서버가 각각 독립적으로 진화할 수 있다.
> <br>   
> **[클라이언트]** : 복잡한 비즈니스 로직, 데이터 제거 이후 단순하게 UI/UX만 어떻게 그릴지 집중할 수 있다.
> <br>   
> **[서버]** : 트래픽이 폭주하는 경우 클라이언트는 건드릴 필요 없이 서버측만 어떻게 더 고도화 하고 집중할 지 고민하면 된다.

<br><br>

## [HTTP 기본 : Stateful, Stateless]
### [HTTP의 중요한 특징 중 하나는 무상태 프로토콜을 지향한다. (Stateless)]
  * 서버가 클라이언트 상태를 보존하지 않음
    > 서버 확장성은 높으나(스케일 아웃) 클라이언트가 추가 데이터를 전송해야한다.

### [Stateful, less의 차이]
* Stateful(상태의 유지) : 서버가 클라이언트의 이전 상태를 보존(문맥 보존)
  * 한 점원이 결제하다 다른 점원으로 바뀌면 진행된 상황을 모르므로 문맥이 사라짐
* Stateless(상태를 유지하지 않음) : 문맥을 보존하지 않음 > **예시는 강의 참조**
  *  무상태는 애초에 클라이언트에서 모든 상황을 전부 제시하므로 점원이 바뀌어도 상관 없음

  > 결국 Stateful은 중간에 다른점원으로 바뀌면 안됨 (바뀌게 되면 상태정보를 바뀌는 점원에게 미리 알려야함)
  >    
  > stateless: 중간에 다른 점원으로 변경 가능   
  > * 갑자기 고객이 증가되도 점원 대거 투입 가능, 클라이언트 요청 증가해도 서버 대거 투입 가능해짐
  > * 결국 무상태는 응답 서버를 쉽게 바꿀 수 있다 -> **무한 서버 증설 가능**

* 무상태는 결국 스케일 아웃(수평확장)에 유리하다.

<br>

### [한계점]
1. 모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다.
   * 로그인은 상태유지 필요(일반적으로 브라우저 쿠키, 서버 세션을 사용함)
2. 데이터를 많이 보내야함 (요구 사항이 모호하지 않고 분명해야 하므로)
* 그렇다 하더라도 상태유지는 최소한만 사용해야 함(어쩔 수 없는 경우에만)

<br><br>

## HTTP 기본 : 비 연결성(connectionless)
* 클라이언트가 3개가 있고 서버에 각각 연결했을때   
  서버 1개가 요청을 해도 다른 2개가 연결되어 있는 상태면 요청이 없어도 서버 자원이 계속 사용된다. (Request, Response 객체 생성 등)

* 따라서 연결을 유지하지 않아야함
  * TCP/IP를 연결하고 요청을 서버가 받으면 즉시 연결을 끊음(필요한것만 주고받고 연결 끊음)
  * 이렇게 되면 서버 입장에서는 요청을 주고받을때만 연결을 하므로 서버가 유지하는 자원 최소화 할 수 있다.
  
### [비 연결성]
**장점**   
* HTTP는 기본이 연결을 유지하지 않는 모델
* 일반적으로 초 단위 이하의 빠른속도로 응답
* 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시 처리 요청은 수십개 이하로 적다
  * 웹 브라우저에서 계속 연속적으로 버튼을 누르지 않기 때문임
* 즉 비연결성은 서버 자원의 효율적 사용 가능   

**단점**   
*  TCP/IP 연결 새로 맺어야 함(3 Way handshake)
*  사이트 요청시 HTML, JS, CSS, 이미지 등 많은 자원 다운로드
*  현재는 HTTP지속 연결(Persistent Connections)로 문제를 해결함
*  HTTP/2, HTTP/3에서 더 많은 최적화가 이루어 졌다.
> 초기 HTTP 연결 종료에서의 낭비는 강의자료 참조)

### STATELESS를 기억
### 서버 개발자들이 어려워하는 업무

* 같은 시간에 딱 맞추어 발생하는 대용량 트래픽
  * KTX예약, 선착순 이벤트, 학과 수업 등록
* 최대한 STATELESS하게 만들면 대용량 트래픽이 와도 서버를 순간 늘려서 대응할 수 있게 한다.
  * 첫 페이지는 정적페이지를 두고 이후 이벤트 참여 버튼을 눌러 딜레이를 만든다.

<br><br>

## HTTP 기본 : HTTP 메시지
  
### HTTP 메시지에 모든 것을 전송

* HTTP의 요청 메시지와 응답 메시지는 구조가 약간 다름
* HTTP 메시지 구조   
  |HTTP 메시지 구조|
  |---------------------------|
  |start-line 시작라인|
  |header 헤더|
  |empty line 공백 라인 (CRLF)|
  |message body|

  |HTTP 요청 메시지|
  |---------------------------|
  |GET /search?q=helloA&hi=ko HTTP/1.1|
  |Host: www.google.com|
  | -공백- (요청 메시지도 body 본문 가질 수 있음)|

  |HTTP 응답 메시지|
  |---------------------------|
  |HTTP/1.1 200 OK(여기서 OK는 사람이 읽을 수 있게 짧게 표기)|
  |Content-Type: text/heml;charset=UTF-8 <br> Context-Length: 3423|
  | -공백- |
  |\<html>html 내용\</html>|

### [시작라인 (요청 메시지)]
* **request-line**, status-line으로 나뉨 (요청 메시지는 request-line)
* **request-line** = **method**(GET, POST등) SP(Space) **request-target**(path들어감) SP **HTTP-version** CRLF(엔터)
  1. HTTP 메서드
      * 종류 : GET, POST, PUT, DELETE
      * 서버가 수행할 동작 지정
        * GET : 리소스 조회
        * POST : 요청 내역 처리
  2. 요청 대상
      * 절대경로로 작성(/로 시작)
      * 다른 유형도 있지만 절대경로를 기억
  3. HTTP 버전

### [시작라인 (응답 메시지)]
* **start-line** = **HTTP-version** SP **status-code(상태코드 성공 실패 여부)** SP **reason-phrase** CRLF
  1. HTTP 버전
  2. HTTP 상태 코드: 요청 성공, 실패 알려줌
      * 200=성공, 400=클라이언트 요청 오류, 500=서버 내부 오류
  3. 이유 문구: 사람이 이해하는 짧은 문장
   
### [HTTP 헤더]
* header-field - field-name":" OWS field-value OWS (OWS: 띄어쓰기 허용)
  * field-name은 대소문자 구분 없다 하지만, value는 구분함
* 용도 : HTTP 전송에 필요한 모든 부가정보 가짐(내용, 크기, 압축, 인증, 요청 등 body제외 필요한 메타이데터 정보 들어감)
* 표준 헤더는 매우 많음

### [HTTP 메시지 바디]
* 실제 전송할 데이터
* byte로 표현할 수 있는 모든 데이터 전송 가능(HTML, 이미지, 영상, JSON등)


### [HTTP == 단순함, 확장 가능 (크게 성공하는 기술 == 단순하지만 확장 가능한 기술)]