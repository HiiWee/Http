## [인터넷 네트워크 : IP(인터넷 프로토콜)]

* IP(인터넷 프로토콜) 역할
  * 지정한 IP 주소에 데이터 전살
  * 패킷(Packet)이라는 통신 단위로 데이터 전달

* IP 패킷 정보   
  * [클라이언트]
  * 전송데이터 외에 출발지IP, 목적지IP 및 메시지를 적어야 한다.
  * 이후 클라이언트는 패킷을 인터넷 망에 던진다.
  * 서로 노드끼리도 패킷 규약을 지키므로 결국 서버측으로 보내짐
  * [서버]
  * 출발지를 자신 목적지를 방금 받은 패킷의 IP, 내용은 잘 받았다는 내용으로 다시 클라이언트에게 보낸다.
* 요청, 응답시에 서로 다른 인터넷망으로 전달 될 수 도 있다.(하지만 목적지는 동일함)
* 하지만 이러한 IP 프로토콜 방식은 한계가 있다.
  * **비연결성**
    * 패킷 받을 대상 없고, 서비스 불능 상태여도 패킷 전송
  * **비신뢰성**
    * 중간에 패킷이 사라지면?
    * 패킷이 순서대로 안오면?(노드 장애, 다중 결로 라우팅과 같이 중간에 유실되거나 지연도착으로 인해 순서가 변경)
  * **프로그램 구분**
    * 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상 일 경우

> 이런 문제를 해결하는 방법이 TCP와 UDP가 있다.

<br><br>

## [인터넷 네트워크 : TCP, UDP]
* 인터넷 프로토콜 스택의 4계층
   
|인터넷 프로토콜 스택의 4계층|
|---------------------------|
|애플리케이션 계층 - HTTP, FTP|
|전송 계층 - TCP, UDP|
|인터넷 계층 - IP|
|네트워크 인터페이스 계층|

* TCP, UDP는 IP라는것에 위에 살짝 얹어서 보완해준다고 생각 좀 더 직관적으로

|||
|-|-|
|**애플리케이션**: |웹 브라우저, 네트워크 게임, 채팅 프로그램|
||[SOCKET 라이브러리]|
|**OS**: |[TCP] [UDP]]|
||IP(Internet Protocol|
|**네트워크 인터페이스**: |[LAN 드라이버, LAN 장비], LAN카드|

LAN 카드가 ---> 인터넷에 연결되고 ----> 서버로 보내짐

**[전송 순서]**   
1. 프로그램이 특정 메시지 생성
2. SOCKET 라이브러리를 통해 전달 (어플리케이션 계층)
3. TCP 정보 생성(패킷), 메시지 데이터 포함 (OS계층)
4. IP 패킷 생성, TCP 데이터 포함 (OS계층)
5. 이후 네트워크 인터페이스를 통해 LAN카드로 나감(이때 이더넷 프레임으로 감싸서 나가짐)

**[IP 패킷 정보]** :출발지 IP, 목적지 IP, 기타   
**[TCP/IP 패킷 정보]** : 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보   
<br>

### **[TCP의 특징]**   
전송 제어 프로토콜 (전송을 어떻게 할지 제어함)
* 연결지향 - TCP 3 way handshake(가상연결) : 연결을 하고 메시지를 보낸다.
* 데이터 전달 보증 : 패킷이 중간에 누락되면 보낸 클라이언트가 알 수 있음
* 순서 보장
> 따라서 TCP는 신뢰할 수 있고 대부분 TCP를 사용한다.

<br>

**TCP의 특징1 : TCP 3 way handshake**
1. SYN : 클라이언트에서 서버로 접속 요청 보냄
2. SYN + ACK(요청수락) : 서버도 수락과 동시에 클라이언트에 접속 요청을 보낸다.
3. ACK : 클라이언트는 요청을 수락한다. 
4. 이렇게 연결이 되고난 후 데이터가 전송된다.  
> ACK와 함꼐 메시지 전송 가능   
> 이렇게 하면 클라이언트와 서버가 서로를 믿을 수 있다.   
> 하지만 위 연결은 진짜로 연결된 것이 아니다.(개념적 연결)   
> 내부 서버들이 진짜로 연결됐는지는 모르고 서버와 클라이언트만 서로 연결됐다고 생각(논리적)

<br>   

**TCP의 특징2 : 데이터 전달 보증**
* TCP가 붙게 되면 서버로 데이터가 전송되면 데이터를 잘 받았다고 클라이언트로 메시지를 다시 보내줌

<br>

**TCP의 특징3 : 순서 보장**
1. 만약 패킷1, 패킷2, 패킷3 순서로 전송했을때
2. 서버에 패킷1, 패킷3, 패킷2 순서로 도착
3. 서버는 클라이언트에게 패킷2부터 다시 보내라고 클라이언트에 요청함

<br>

**이렇게 TCP의 특징들이 전부 가능한 이유는 TCP데이터 안에 전송제어, 순서, 검증 정보들이 포함되어 있기 때문이다. 따라서 TCP를 신뢰할 수 있는 프로토콜이라 말함**

<br>

### **[UDP의 특징]**   
사용자 데이터그램 프로토콜

* 하얀 도화지에 비유 (기능 거의 없음)
* 연결지향 - TCP 3 way handshake, 데이터 전달, 순서 보증 지원 안됨 따라서 단순하고 빠름
* IP와 거의 같지만 **PORT** 체크섬(메시지에 대해 올바른지 검증) 정도만 추가됨
> **PORT:** 하나의 IP에서 여러 애플리케이션을 이용할 때 여러 패킷이 이용되는데 이 때 각 패킷이 어떤 애플리케이션에서 이용되는 패킷인지 구분해주는 역할을 한다.   
> **UDP는 왜 쓸까?** : TCP는 3 way hs에서 시간이 많이 소요되고, 각종 데이터들의 양이 크므로 전송속도를 증가시키기 어렵다 이미 인터넷이 TCP기반이라 손을 댈 수 없다.   
> 따라서 더 최적화 하고 싶으면 TCP는 그대로 두고 UDP를 이용   
> UDP는 아무것도 없기 때문에 원하는것을 애플리케이션 레벨에서 만들면 된다. (요즘 각광 받음)

<br><br>

## [인터넷 네트워크 : PORT]
* 만약 한번에 둘 이상 연결해야 한다면 (게임, 화상통화, 웹 브라우저) 클라이언트 PC가 여러개의 서버와 통신해야 함
* 이때 각 서버에서 패킷들이 클라이언트로 날라오는데 어디에서 필요한 패킷인지 구분하기 힘듦
* TCP/IP 패킷 정보에는 출발지 PORT, 목적지 PORT가 존재한다.
  * **IP** : 목적지 서버를 찾거나, 출발지 클라이언트를 찾기 위함
  * **PORT** : 클라이언트 서버안에서 돌아가는 애플리케이션을 구분하기 위함
* 따라서 같은 IP내에서 프로세스를 구분하는것이 포트가 된다.
* 출발지 PORT, 목적지 PORT가 TCP 패킷에 존재하므로 서버로 요청할 때는 목적지 PORT를 이용하고,   
  반대로 서버에서 응답이 올때는 출발지 PORT를 이용해 응답이 온다.
  |웹 브라우저 요청 예시|출발지|목적지|
  |-|-|-|
  |IP|100.100.100.1|200.200.200.2|
  |PORT|10010|80|
  > 위와 같이 있을 때 브라우저 요청은 200.200.200.2:80으로 요청한다.   
  > 서버측은 브라우저를 100.100.100.1:10010으로 응답해 띄워준다.   
  > IP는 아파트 PORT는 몇동 몇호

<br><br>

## [인터넷 네트워크 : DNS]
* IP는 기억하기 어렵다는 문제가 있고, 변경될 수 있다.
  * 변경이 되면 접근을 할 수 없다.
* 따라서 DNS 도메인 네임 시스템을 이용한다.
  * 중간에 전화번호부 같은 서버를 제공한다.
  * 즉 도메인 명을 IP 주소로 변환한다.

  DNS 서버
  |도메인 명| IP|
  |-|-|
  |google.com|200.200.200.2|
  |aaa.com|210.210.210.3|
  > 이렇게 DNS 서버가 있을떄 어떻게 사용할까?   
  > 1. 클라이언트가 도메인 명으로 요청
  > 2. DNS서버가 응답으로 IP를 알려줌
  > 3. 받은 IP로 클라이언트는 서버로 접속한다.
  
<br><br>

## [URI와 웹 브라우저 요청 흐름 : URI]
**URI : Uniform Resource Identifier**   
URL는 로케이터(locator)와 이름(name)또는 둘 다 추가로 분류될 수 있다.

* URI는 주민번호처럼 자원 자체를 식별하는 방법이다.
* 여기에 크게 2가지가 있다.
  * URL(Resource Locator) : 리소스의 위치(거의 URL만 사용)
    > foo://example.com:8042/over/there?name=ferret#nose
  * URN(Resource Name) : 리소스의 이름
    > urn:example:animal:ferret:nose

* URI 단어의 뜻
  * Uniform : 리소스 식별하는 통일된 방식
  * Resource : 자원, URI로 식별할 수 있는 모든 것 (제한 없음)
  * Identifier: 다른 항목과 구분하는데 필요한 정보
  * URL의 Locator : 리소스가 있는 위치를 지정
  * URN의 Name : 리소스에 이름을 부여
  * 위치는 변할 수 있지만, 이름은 변하지 않음
  * URN이름만으로 실제 리소스 찾는 것은 보편화 되지 않음
  * 따라서 URI를 URL과 같은 의미로 이야기 함
<br><br>
* URL의 문법
  * sceme://[userinfo@]host[:port][/path][?query][#fragment]
  * https://www.google.com:443/search?q=hello&hl=ko
  
  * URL scheme
    * 프로토콜(https)
    * 주로 프로토콜(어떤 방식으로 자원에 접근하는지의 클라이언트 서버간 약속, 규칙) 사용 (예:http, https, ftp등)
    * http는 80, https 443 포트 사용(생략가능)
    * https는 https에 추가보안(HTTP secure)
  * URL userinfo
    * URL에 사용자 정보를 포함해 인증하지만 거의 사용하지 않음
  * URL host
    * 호스트명(www.google.com)
    * 도메인 명 또는 IP주소를 직접 사용 가능
  * URL PORT
    * 포트 번호(443)
    * 포트, 접속 포트(일반적으로 생략)
  * URL path
    * 패스(/search)
    * 리소스 경로, 계층적 구조
    * /home/file.jpg 혹은 /members/100과 같이 계층적
  * URL query
    * 쿼리 파라미터(q=hello&hl=ko)
    * key = value 형태
    * ?로 시작, &로 추가 가능(?keyA=valueA&keyB=valueB)
    * query parameter, query string 등으로 불림, 웹 서버에 제공하는 파라미터, 문자 형태임
  * URL fragment
    * html 내부 북마크 등에 사용
    * 서버에 전송하는 정보 아님

<br><br>

## [URI와 웹 브라우저 요청 흐름 : 웹 브라우저 요청 흐름]
https://www.google.com:443/search?q=hello&hl=ko 이렇게 보내게 되면   
먼저 DNS 조회를 한다 --> IP 추출(HTTPS PORT 생략, 443)   
1. 웹 브라우저가 HTTP 요청 메시지를 생성한다.
   * 메시지 내용 : `GET /search?q=hello&hi=ko HTTP/1.1 HOST: www.google.com`
2. SOCKET 라이브러리를 통해 전달
    - A: TCP/IP연결(IP, PORT)
    - B: 데이터 전달
3. TCP/IP 패킷 생성, HTTP 메시지 포함 이후 인터넷으로 흘러들어감

결국 출발지 IP and PORT, 목적지 IP and PORT, 전송데이터(웹브라우저가 만든 HTTP 요청 메시지)가 만들어짐   
이후 인터넷 망으로 요청 패킷 던져짐, 구글 서버는 요청 패킷을 받아서 TCP/IP는 버리고 HTTP 메시지를 받아서 분석하고 HTTP 응답 메시지를 만들고 TCP/IP로 씌워서 응답 패킷을 만들어 반환한다.
  * HTTP 응답 메시지
  > HTTP/1.1 200 OK   
  > Content-Type: text/html;charset=UTF-8(인코딩)   
  > Content-Length: 3423(실제 길이)   
  > -HTML코드-

이후 클라이언트가 응답 패킷의 HTTP 응답 메시지를 열면 html결과를 볼 수 있게 된다.


<br><br>

## [HTTP 기본 : 모든 것이 HTTP]
* HTTP - HyperText Transfer Protocol
* 모든 것이 HTTP - HTTP 메시지에 모든 것을 전송
  * HTML, TEXT
  * IMAGE, 음성, 영상, 파일
  * JSON, XML(API)
  * 거의 모든 형태의 데이터 전송 가능
  * 서버간 데이터를 주고 받을 때도 대부분 HTTP 사용함

* HTTP1.1을 가장 많이 사용
  * 대부분의 성능들이 이때 만들어짐

* 기반 프로토콜
  * TCP : HTTP/1.1, HTTP/2는 TCP프로토콜 위에서 동작함
  * UDP : HTTP/3는 UDP기반으로 만들어짐
  * 현재는 1.1을 주로 사용한다

* HTTP의 특징
  * 클라이언트-서버 구조로 동작함
  * 무상태 프로토콜(Stateless), 비연결성
  * HTTP메시지를 통해서 통신을 함(수신, 송신)
  * HTTP는 굉장히 단순하고 확장 가능하다.

> HTTP1.1에 현재 많이 사용하는 대부분의 기능들이 만들어졌다.   
> 2, 3는 1.1의 성능개선에 초점이 맞추어짐 따라서 1.1을 잘 알아야 한다.

<br><br>

## [HTTP 기본 : 클라이언트 서버 구조]
* Request Response 구조
* HTTP는 클라이언트가 HTTP메시지를 통햇 서버에 요청을 보낸다.   
  클라이언트는 서버의 응답이 올때까지 기다린다.   
  서버가 요청에 대한 결과를 만들어서 클라이언트에 응답하면 응답 결과를 열어서 클라이언트가 동작한다.
> 위와 같은 이유는 표면적인 이유다.   
> 이렇게 분리를 하는것이 매우 중요함 왜? 
> <br>  
> 클라이언트와 서버를 분리를 한 후 **비즈니스 로직, 데이터**들을 서버에 밀어 넣는다.   
> 이후 클라이언트는 바로 UI, 사용성에 집중을 한다.   
> 이렇게 되면 클라이언트, 서버가 각각 독립적으로 진화할 수 있다.
> <br>   
> **[클라이언트]** : 복잡한 비즈니스 로직, 데이터 제거 이후 단순하게 UI/UX만 어떻게 그릴지 집중할 수 있다.
> <br>   
> **[서버]** : 트래픽이 폭주하는 경우 클라이언트는 건드릴 필요 없이 서버측만 어떻게 더 고도화 하고 집중할 지 고민하면 된다.

<br><br>

## [HTTP 메서드 : HTTP API를 만들어보자]
* 회원정보관리 api를 만들려고 할 때 나오는 동작들은
  * 회원 목록 조회, 회원 조회, 회원 등록, 회원 수정, 회원 삭제 등이 있다.

* 그렇다면 API URI를 설계 할 때 위의 동작들을 모두 각각 URI로 설계해야 할까?
  * 좋지 못한 설계 URI의 설계 기준은 리소스다.
* **URI설계에서 가장 중요한 것은 리소스를 식별하는 것이다.** 
  * 리소스의 의미 : 회원 등록, 조회, 수정, 삭제 등 동작이 기준이 아닌 **회원이라는 개념 자체**
  * 리소스 식별 방법 : 회원에 관한 동적 행위들은 모두 배제 후 회원이라는 리소스만 식별한다.   
    **회원이라는 리소스만 식별하면 됨 -> 회원 리소스를 URI에 매핑**

### 리소스를 식별한 API URI설계
  * 회원 목록 조회 /members
  * 회원 조회 /members/{id}
  * 회원 등록 /members/{id}
  * 회원 수정 /members/{id}
  * 회원 삭제 /members/{id}
  > 계층 구조상 상위를 컬렉션으로 보고 **복수 단어**를 사용하길 권장함
  
  <br>

  * 위와 같은 구조에서 각각의 동작(수정, 조회, 삭제 등)들을 구분하는 방법?
    * 보기에는 모두 같은 URI가 매칭됐다. 이걸 어떻게 구분하여 동작시킬까?
    * 리소스 == 명사, 행위 == 동사
    * URI는 리소스(명사)를 식별하는데만 사용된다.
    * 따라서 리소스와 해당 리소스를 대상으로 하는 **행위**로 분리한다.
      * 리소스 : 회원
      * 행위 : 조회, 등록, 수정, 삭제 등
    * 리소스의 행위(동사)는 **HTTP method (GET, POST, PUT, DELETE)** 를 이용해 구분