## [인터넷 네트워크 : IP(인터넷 프로토콜)]

* IP(인터넷 프로토콜) 역할
  * 지정한 IP 주소에 데이터 전살
  * 패킷(Packet)이라는 통신 단위로 데이터 전달

* IP 패킷 정보   
  * [클라이언트]
  * 전송데이터 외에 출발지IP, 목적지IP 및 메시지를 적어야 한다.
  * 이후 클라이언트는 패킷을 인터넷 망에 던진다.
  * 서로 노드끼리도 패킷 규약을 지키므로 결국 서버측으로 보내짐
  * [서버]
  * 출발지를 자신 목적지를 방금 받은 패킷의 IP, 내용은 잘 받았다는 내용으로 다시 클라이언트에게 보낸다.
* 요청, 응답시에 서로 다른 인터넷망으로 전달 될 수 도 있다.(하지만 목적지는 동일함)
* 하지만 이러한 IP 프로토콜 방식은 한계가 있다.
  * **비연결성**
    * 패킷 받을 대상 없고, 서비스 불능 상태여도 패킷 전송
  * **비신뢰성**
    * 중간에 패킷이 사라지면?
    * 패킷이 순서대로 안오면?(노드 장애, 다중 결로 라우팅과 같이 중간에 유실되거나 지연도착으로 인해 순서가 변경)
  * **프로그램 구분**
    * 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상 일 경우

> 이런 문제를 해결하는 방법이 TCP와 UDP가 있다.

<br><br>

## [인터넷 네트워크 : TCP, UDP]
* 인터넷 프로토콜 스택의 4계층
   
|인터넷 프로토콜 스택의 4계층|
|---------------------------|
|애플리케이션 계층 - HTTP, FTP|
|전송 계층 - TCP, UDP|
|인터넷 계층 - IP|
|네트워크 인터페이스 계층|

* TCP, UDP는 IP라는것에 위에 살짝 얹어서 보완해준다고 생각 좀 더 직관적으로

|||
|-|-|
|**애플리케이션**: |웹 브라우저, 네트워크 게임, 채팅 프로그램|
||[SOCKET 라이브러리]|
|**OS**: |[TCP] [UDP]]|
||IP(Internet Protocol|
|**네트워크 인터페이스**: |[LAN 드라이버, LAN 장비], LAN카드|

LAN 카드가 ---> 인터넷에 연결되고 ----> 서버로 보내짐

**[전송 순서]**   
1. 프로그램이 특정 메시지 생성
2. SOCKET 라이브러리를 통해 전달 (어플리케이션 계층)
3. TCP 정보 생성(패킷), 메시지 데이터 포함 (OS계층)
4. IP 패킷 생성, TCP 데이터 포함 (OS계층)
5. 이후 네트워크 인터페이스를 통해 LAN카드로 나감(이때 이더넷 프레임으로 감싸서 나가짐)

**[IP 패킷 정보]** :출발지 IP, 목적지 IP, 기타   
**[TCP/IP 패킷 정보]** : 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보   
<br>

### **[TCP의 특징]**   
전송 제어 프로토콜 (전송을 어떻게 할지 제어함)
* 연결지향 - TCP 3 way handshake(가상연결) : 연결을 하고 메시지를 보낸다.
* 데이터 전달 보증 : 패킷이 중간에 누락되면 보낸 클라이언트가 알 수 있음
* 순서 보장
> 따라서 TCP는 신뢰할 수 있고 대부분 TCP를 사용한다.

<br>

**TCP의 특징1 : TCP 3 way handshake**
1. SYN : 클라이언트에서 서버로 접속 요청 보냄
2. SYN + ACK(요청수락) : 서버도 수락과 동시에 클라이언트에 접속 요청을 보낸다.
3. ACK : 클라이언트는 요청을 수락한다. 
4. 이렇게 연결이 되고난 후 데이터가 전송된다.  
> ACK와 함꼐 메시지 전송 가능   
> 이렇게 하면 클라이언트와 서버가 서로를 믿을 수 있다.   
> 하지만 위 연결은 진짜로 연결된 것이 아니다.(개념적 연결)   
> 내부 서버들이 진짜로 연결됐는지는 모르고 서버와 클라이언트만 서로 연결됐다고 생각(논리적)

<br>   

**TCP의 특징2 : 데이터 전달 보증**
* TCP가 붙게 되면 서버로 데이터가 전송되면 데이터를 잘 받았다고 클라이언트로 메시지를 다시 보내줌

<br>

**TCP의 특징3 : 순서 보장**
1. 만약 패킷1, 패킷2, 패킷3 순서로 전송했을때
2. 서버에 패킷1, 패킷3, 패킷2 순서로 도착
3. 서버는 클라이언트에게 패킷2부터 다시 보내라고 클라이언트에 요청함

<br>

**이렇게 TCP의 특징들이 전부 가능한 이유는 TCP데이터 안에 전송제어, 순서, 검증 정보들이 포함되어 있기 때문이다. 따라서 TCP를 신뢰할 수 있는 프로토콜이라 말함**

<br>

### **[UDP의 특징]**   
사용자 데이터그램 프로토콜

* 하얀 도화지에 비유 (기능 거의 없음)
* 연결지향 - TCP 3 way handshake, 데이터 전달, 순서 보증 지원 안됨 따라서 단순하고 빠름
* IP와 거의 같지만 **PORT** 체크섬(메시지에 대해 올바른지 검증) 정도만 추가됨
> **PORT:** 하나의 IP에서 여러 애플리케이션을 이용할 때 여러 패킷이 이용되는데 이 때 각 패킷이 어떤 애플리케이션에서 이용되는 패킷인지 구분해주는 역할을 한다.   
> **UDP는 왜 쓸까?** : TCP는 3 way hs에서 시간이 많이 소요되고, 각종 데이터들의 양이 크므로 전송속도를 증가시키기 어렵다 이미 인터넷이 TCP기반이라 손을 댈 수 없다.   
> 따라서 더 최적화 하고 싶으면 TCP는 그대로 두고 UDP를 이용   
> UDP는 아무것도 없기 때문에 원하는것을 애플리케이션 레벨에서 만들면 된다. (요즘 각광 받음)

<br><br>

## [인터넷 네트워크 : PORT]
* 만약 한번에 둘 이상 연결해야 한다면 (게임, 화상통화, 웹 브라우저) 클라이언트 PC가 여러개의 서버와 통신해야 함
* 이때 각 서버에서 패킷들이 클라이언트로 날라오는데 어디에서 필요한 패킷인지 구분하기 힘듦
* TCP/IP 패킷 정보에는 출발지 PORT, 목적지 PORT가 존재한다.
  * **IP** : 목적지 서버를 찾거나, 출발지 클라이언트를 찾기 위함
  * **PORT** : 클라이언트 서버안에서 돌아가는 애플리케이션을 구분하기 위함
* 따라서 같은 IP내에서 프로세스를 구분하는것이 포트가 된다.
* 출발지 PORT, 목적지 PORT가 TCP 패킷에 존재하므로 서버로 요청할 때는 목적지 PORT를 이용하고,   
  반대로 서버에서 응답이 올때는 출발지 PORT를 이용해 응답이 온다.
  |웹 브라우저 요청 예시|출발지|목적지|
  |-|-|-|
  |IP|100.100.100.1|200.200.200.2|
  |PORT|10010|80|
  > 위와 같이 있을 때 브라우저 요청은 200.200.200.2:80으로 요청한다.   
  > 서버측은 브라우저를 100.100.100.1:10010으로 응답해 띄워준다.   
  > IP는 아파트 PORT는 몇동 몇호

<br><br>

## [인터넷 네트워크 : DNS]
* IP는 기억하기 어렵다는 문제가 있고, 변경될 수 있다.
  * 변경이 되면 접근을 할 수 없다.
* 따라서 DNS 도메인 네임 시스템을 이용한다.
  * 중간에 전화번호부 같은 서버를 제공한다.
  * 즉 도메인 명을 IP 주소로 변환한다.

  DNS 서버
  |도메인 명| IP|
  |-|-|
  |google.com|200.200.200.2|
  |aaa.com|210.210.210.3|
  > 이렇게 DNS 서버가 있을떄 어떻게 사용할까?   
  > 1. 클라이언트가 도메인 명으로 요청
  > 2. DNS서버가 응답으로 IP를 알려줌
  > 3. 받은 IP로 클라이언트는 서버로 접속한다.
  
<br><br>

## [URI와 웹 브라우저 요청 흐름 : URI]
**URI : Uniform Resource Identifier**   
URL는 로케이터(locator)와 이름(name)또는 둘 다 추가로 분류될 수 있다.

* URI는 주민번호처럼 자원 자체를 식별하는 방법이다.
* 여기에 크게 2가지가 있다.
  * URL(Resource Locator) : 리소스의 위치(거의 URL만 사용)
    > foo://example.com:8042/over/there?name=ferret#nose
  * URN(Resource Name) : 리소스의 이름
    > urn:example:animal:ferret:nose

* URI 단어의 뜻
  * Uniform : 리소스 식별하는 통일된 방식
  * Resource : 자원, URI로 식별할 수 있는 모든 것 (제한 없음)
  * Identifier: 다른 항목과 구분하는데 필요한 정보
  * URL의 Locator : 리소스가 있는 위치를 지정
  * URN의 Name : 리소스에 이름을 부여
  * 위치는 변할 수 있지만, 이름은 변하지 않음
  * URN이름만으로 실제 리소스 찾는 것은 보편화 되지 않음
  * 따라서 URI를 URL과 같은 의미로 이야기 함
<br><br>
* URL의 문법
  * sceme://[userinfo@]host[:port][/path][?query][#fragment]
  * https://www.google.com:443/search?q=hello&hl=ko
  
  * URL scheme
    * 프로토콜(https)
    * 주로 프로토콜(어떤 방식으로 자원에 접근하는지의 클라이언트 서버간 약속, 규칙) 사용 (예:http, https, ftp등)
    * http는 80, https 443 포트 사용(생략가능)
    * https는 https에 추가보안(HTTP secure)
  * URL userinfo
    * URL에 사용자 정보를 포함해 인증하지만 거의 사용하지 않음
  * URL host
    * 호스트명(www.google.com)
    * 도메인 명 또는 IP주소를 직접 사용 가능
  * URL PORT
    * 포트 번호(443)
    * 포트, 접속 포트(일반적으로 생략)
  * URL path
    * 패스(/search)
    * 리소스 경로, 계층적 구조
    * /home/file.jpg 혹은 /members/100과 같이 계층적
  * URL query
    * 쿼리 파라미터(q=hello&hl=ko)
    * key = value 형태
    * ?로 시작, &로 추가 가능(?keyA=valueA&keyB=valueB)
    * query parameter, query string 등으로 불림, 웹 서버에 제공하는 파라미터, 문자 형태임
  * URL fragment
    * html 내부 북마크 등에 사용
    * 서버에 전송하는 정보 아님

<br><br>

## [URI와 웹 브라우저 요청 흐름 : 웹 브라우저 요청 흐름]
https://www.google.com:443/search?q=hello&hl=ko 이렇게 보내게 되면   
먼저 DNS 조회를 한다 --> IP 추출(HTTPS PORT 생략, 443)   
1. 웹 브라우저가 HTTP 요청 메시지를 생성한다.
   * 메시지 내용 : `GET /search?q=hello&hi=ko HTTP/1.1 HOST: www.google.com`
2. SOCKET 라이브러리를 통해 전달
    - A: TCP/IP연결(IP, PORT)
    - B: 데이터 전달
3. TCP/IP 패킷 생성, HTTP 메시지 포함 이후 인터넷으로 흘러들어감

결국 출발지 IP and PORT, 목적지 IP and PORT, 전송데이터(웹브라우저가 만든 HTTP 요청 메시지)가 만들어짐   
이후 인터넷 망으로 요청 패킷 던져짐, 구글 서버는 요청 패킷을 받아서 TCP/IP는 버리고 HTTP 메시지를 받아서 분석하고 HTTP 응답 메시지를 만들고 TCP/IP로 씌워서 응답 패킷을 만들어 반환한다.
  * HTTP 응답 메시지
  > HTTP/1.1 200 OK   
  > Content-Type: text/html;charset=UTF-8(인코딩)   
  > Content-Length: 3423(실제 길이)   
  > -HTML코드-

이후 클라이언트가 응답 패킷의 HTTP 응답 메시지를 열면 html결과를 볼 수 있게 된다.


<br><br>

## [HTTP 기본 : 모든 것이 HTTP]
* HTTP - HyperText Transfer Protocol
* 모든 것이 HTTP - HTTP 메시지에 모든 것을 전송
  * HTML, TEXT
  * IMAGE, 음성, 영상, 파일
  * JSON, XML(API)
  * 거의 모든 형태의 데이터 전송 가능
  * 서버간 데이터를 주고 받을 때도 대부분 HTTP 사용함

* HTTP1.1을 가장 많이 사용
  * 대부분의 성능들이 이때 만들어짐

* 기반 프로토콜
  * TCP : HTTP/1.1, HTTP/2는 TCP프로토콜 위에서 동작함
  * UDP : HTTP/3는 UDP기반으로 만들어짐
  * 현재는 1.1을 주로 사용한다

* HTTP의 특징
  * 클라이언트-서버 구조로 동작함
  * 무상태 프로토콜(Stateless), 비연결성
  * HTTP메시지를 통해서 통신을 함(수신, 송신)
  * HTTP는 굉장히 단순하고 확장 가능하다.

> HTTP1.1에 현재 많이 사용하는 대부분의 기능들이 만들어졌다.   
> 2, 3는 1.1의 성능개선에 초점이 맞추어짐 따라서 1.1을 잘 알아야 한다.

<br><br>

## [HTTP 기본 : 클라이언트 서버 구조]
* Request Response 구조
* HTTP는 클라이언트가 HTTP메시지를 통햇 서버에 요청을 보낸다.   
  클라이언트는 서버의 응답이 올때까지 기다린다.   
  서버가 요청에 대한 결과를 만들어서 클라이언트에 응답하면 응답 결과를 열어서 클라이언트가 동작한다.
> 위와 같은 이유는 표면적인 이유다.   
> 이렇게 분리를 하는것이 매우 중요함 왜? 
> <br>  
> 클라이언트와 서버를 분리를 한 후 **비즈니스 로직, 데이터**들을 서버에 밀어 넣는다.   
> 이후 클라이언트는 바로 UI, 사용성에 집중을 한다.   
> 이렇게 되면 클라이언트, 서버가 각각 독립적으로 진화할 수 있다.
> <br>   
> **[클라이언트]** : 복잡한 비즈니스 로직, 데이터 제거 이후 단순하게 UI/UX만 어떻게 그릴지 집중할 수 있다.
> <br>   
> **[서버]** : 트래픽이 폭주하는 경우 클라이언트는 건드릴 필요 없이 서버측만 어떻게 더 고도화 하고 집중할 지 고민하면 된다.

## [HTTP 기본 : Stateful, Stateless]
### [HTTP의 중요한 특징 중 하나는 무상태 프로토콜을 지향한다. (Stateless)]
  * 서버가 클라이언트 상태를 보존하지 않음
    > 서버 확장성은 높으나(스케일 아웃) 클라이언트가 추가 데이터를 전송해야한다.

### [Stateful, less의 차이]
* Stateful(상태의 유지) : 서버가 클라이언트의 이전 상태를 보존(문맥 보존)
  * 한 점원이 결제하다 다른 점원으로 바뀌면 진행된 상황을 모르므로 문맥이 사라짐
* Stateless(상태를 유지하지 않음) : 문맥을 보존하지 않음 > **예시는 강의 참조**
  *  무상태는 애초에 클라이언트에서 모든 상황을 전부 제시하므로 점원이 바뀌어도 상관 없음

  > 결국 Stateful은 중간에 다른점원으로 바뀌면 안됨 (바뀌게 되면 상태정보를 바뀌는 점원에게 미리 알려야함)
  >    
  > stateless: 중간에 다른 점원으로 변경 가능   
  > * 갑자기 고객이 증가되도 점원 대거 투입 가능, 클라이언트 요청 증가해도 서버 대거 투입 가능해짐
  > * 결국 무상태는 응답 서버를 쉽게 바꿀 수 있다 -> **무한 서버 증설 가능**

* 무상태는 결국 스케일 아웃(수평확장)에 유리하다.

<br>

### [한계점]
1. 모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다.
   * 로그인은 상태유지 필요(일반적으로 브라우저 쿠키, 서버 세션을 사용함)
2. 데이터를 많이 보내야함 (요구 사항이 모호하지 않고 분명해야 하므로)
* 그렇다 하더라도 상태유지는 최소한만 사용해야 함(어쩔 수 없는 경우에만)

<br><br>

## [HTTP 기본 : 비 연결성(connectionless)]
* 클라이언트가 3개가 있고 서버에 각각 연결했을때   
  서버 1개가 요청을 해도 다른 2개가 연결되어 있는 상태면 요청이 없어도 서버 자원이 계속 사용된다. (Request, Response 객체 생성 등)

* 따라서 연결을 유지하지 않아야함
  * TCP/IP를 연결하고 요청을 서버가 받으면 즉시 연결을 끊음(필요한것만 주고받고 연결 끊음)
  * 이렇게 되면 서버 입장에서는 요청을 주고받을때만 연결을 하므로 서버가 유지하는 자원 최소화 할 수 있다.
  
### [비 연결성]
**장점**   
* HTTP는 기본이 연결을 유지하지 않는 모델
* 일반적으로 초 단위 이하의 빠른속도로 응답
* 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시 처리 요청은 수십개 이하로 적다
  * 웹 브라우저에서 계속 연속적으로 버튼을 누르지 않기 때문임
* 즉 비연결성은 서버 자원의 효율적 사용 가능   

**단점**   
*  TCP/IP 연결 새로 맺어야 함(3 Way handshake)
*  사이트 요청시 HTML, JS, CSS, 이미지 등 많은 자원 다운로드
*  현재는 HTTP지속 연결(Persistent Connections)로 문제를 해결함
*  HTTP/2, HTTP/3에서 더 많은 최적화가 이루어 졌다.
> 초기 HTTP 연결 종료에서의 낭비는 강의자료 참조)

### STATELESS를 기억
### 서버 개발자들이 어려워하는 업무

* 같은 시간에 딱 맞추어 발생하는 대용량 트래픽
  * KTX예약, 선착순 이벤트, 학과 수업 등록
* 최대한 STATELESS하게 만들면 대용량 트래픽이 와도 서버를 순간 늘려서 대응할 수 있게 한다.
  * 첫 페이지는 정적페이지를 두고 이후 이벤트 참여 버튼을 눌러 딜레이를 만든다.

<br><br>

## [HTTP 기본 : HTTP 메시지]
  
### HTTP 메시지에 모든 것을 전송

* HTTP의 요청 메시지와 응답 메시지는 구조가 약간 다름
* HTTP 메시지 구조   
  |HTTP 메시지 구조|
  |---------------------------|
  |start-line 시작라인|
  |header 헤더|
  |empty line 공백 라인 (CRLF)|
  |message body|

  |HTTP 요청 메시지|
  |---------------------------|
  |GET /search?q=helloA&hi=ko HTTP/1.1|
  |Host: www.google.com|
  | -공백- (요청 메시지도 body 본문 가질 수 있음)|

  |HTTP 응답 메시지|
  |---------------------------|
  |HTTP/1.1 200 OK(여기서 OK는 사람이 읽을 수 있게 짧게 표기)|
  |Content-Type: text/heml;charset=UTF-8 <br> Context-Length: 3423|
  | -공백- |
  |\<html>html 내용\</html>|

### [시작라인 (요청 메시지)]
* **request-line**, status-line으로 나뉨 (요청 메시지는 request-line)
* **request-line** = **method**(GET, POST등) SP(Space) **request-target**(path들어감) SP **HTTP-version** CRLF(엔터)
  1. HTTP 메서드
      * 종류 : GET, POST, PUT, DELETE
      * 서버가 수행할 동작 지정
        * GET : 리소스 조회
        * POST : 요청 내역 처리
  2. 요청 대상
      * 절대경로로 작성(/로 시작)
      * 다른 유형도 있지만 절대경로를 기억
  3. HTTP 버전

### [시작라인 (응답 메시지)]
* **start-line** = **HTTP-version** SP **status-code(상태코드 성공 실패 여부)** SP **reason-phrase** CRLF
  1. HTTP 버전
  2. HTTP 상태 코드: 요청 성공, 실패 알려줌
      * 200=성공, 400=클라이언트 요청 오류, 500=서버 내부 오류
  3. 이유 문구: 사람이 이해하는 짧은 문장
   
### [HTTP 헤더]
* header-field - field-name":" OWS field-value OWS (OWS: 띄어쓰기 허용)
  * field-name은 대소문자 구분 없다 하지만, value는 구분함
* 용도 : HTTP 전송에 필요한 모든 부가정보 가짐(내용, 크기, 압축, 인증, 요청 등 body제외 필요한 메타이데터 정보 들어감)
* 표준 헤더는 매우 많음

### [HTTP 메시지 바디]
* 실제 전송할 데이터
* byte로 표현할 수 있는 모든 데이터 전송 가능(HTML, 이미지, 영상, JSON등)


### [HTTP == 단순함, 확장 가능 (크게 성공하는 기술 == 단순하지만 확장 가능한 기술)]

<br><br>

## [HTTP 메서드 : HTTP API를 만들어보자]
* 회원정보관리 api를 만들려고 할 때 나오는 동작들은
  * 회원 목록 조회, 회원 조회, 회원 등록, 회원 수정, 회원 삭제 등이 있다.

* 그렇다면 API URI를 설계 할 때 위의 동작들을 모두 각각 URI로 설계해야 할까?
  * 좋지 못한 설계 URI의 설계 기준은 리소스다.
* **URI설계에서 가장 중요한 것은 리소스를 식별하는 것이다.** 
  * 리소스의 의미 : 회원 등록, 조회, 수정, 삭제 등 동작이 기준이 아닌 **회원이라는 개념 자체**
  * 리소스 식별 방법 : 회원에 관한 동적 행위들은 모두 배제 후 회원이라는 리소스만 식별한다.   
    **회원이라는 리소스만 식별하면 됨 -> 회원 리소스를 URI에 매핑**

### 리소스를 식별한 API URI설계
  * 회원 목록 조회 /members
  * 회원 조회 /members/{id}
  * 회원 등록 /members/{id}
  * 회원 수정 /members/{id}
  * 회원 삭제 /members/{id}
  > 계층 구조상 상위를 컬렉션으로 보고 **복수 단어**를 사용하길 권장함
  
  <br>

  * 위와 같은 구조에서 각각의 동작(수정, 조회, 삭제 등)들을 구분하는 방법?
    * 보기에는 모두 같은 URI가 매칭됐다. 이걸 어떻게 구분하여 동작시킬까?
    * 리소스 == 명사, 행위 == 동사
    * URI는 리소스(명사)를 식별하는데만 사용된다.
    * 따라서 리소스와 해당 리소스를 대상으로 하는 **행위**로 분리한다.
      * 리소스 : 회원
      * 행위 : 조회, 등록, 수정, 삭제 등
    * 리소스의 행위(동사)는 **HTTP method (GET, POST, PUT, DELETE)** 를 이용해 구분

<br><br>

## [HTTP 메서드 : GET, POST]
HTTP  메서드는 클라이언트가 서버에 무엇인가를 요청을 할 때 기대하는 행동   
**GET**:  무엇인가를 달라고 요청   
**POST** : 데이터를 줄테니 등록 혹은 처리를 해달라는 요청

### 주요 메서드
1. GET : 리소스 조회
2. POST : 요청 데이터 처리, 주로 등록에 사용
3. PUT : 클라이언트 - 서버로 리소스를 보내는데 이 리소스로 대체, 해당 리소스가 없으면 생성
4. PATCH : 리소스의 부분 변경 (이름, 특정 필드 등)
5. DELETE : 리소스 삭제
6. HEAD : GET과 동일하지만 메시지 부분을 제외하고 , 상태줄과 헤더만 반환
7. OPTIONS : CORS서 주로 사용 대상 리소스에 대한 통신 가능 옵션을 설명

### GET
**리소스 조회가 주 목적 **  
서버에 전달하고 싶은 데이터 query를 통해 전달(쿼리 스트링, 쿼리 파라미터)   
메시지 바디를 사용해서 데이터 전달가능하지만, 지원 하지 않는곳 많아 실무에선 사용하지 않음   
<br>

**GET 동작 예시**   
1. 클라이언트가 GET /members/100 HTTP/1.1로 요청을 보내면

2. 서버에서 메시지를 열어보고 DB조회 후 JSON(다른것도가능)형태로 만들고 응답 메시지를 만들어서 클라이언트로 보낸다.

3. 이후 클라이언트에선 이 메시지를 가지고 이용할것이다. 
> (그림은 강의자료 참조)

### POST
클라이언트에서 서버로 요청을 보낼때 특정 데이터를 줌   
서버는 이를 받아서 **요청 데이터를 처리**  
즉 메시지 바디를 통해 서버로 요청 데이터 전달   
서버는 요청 데이터를 처리 (메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.)   
주로 전달된 데이터로 **신규 리소스 등록**, **프로세스 처리**에 사용함
<br>

**POST 동작 예시**
* 클라이언트가 서버로 
  ```
  POST / members HTTP/1.1
  Content-Type: application/json
  {
    "username": "young",
    "age": 20
  }
  ```
  위와 같은 메시지를 /members로 전달

* 이 때 약속을 해야함   
  (클라이언트가 /members에 post로 보내면 그 데이터는 내가 저장할지, 내부적 프로세스에 사용할것인지 미리 약속함 여기서는 신규등록으로 가정)

* 서버는 메시지를 받아 열어보고 데이터를 가지고 신규 등록(DB)을 한다.

* 이후 신규 아이디를 만들어서 신규 리소스 식별자 생성을 함(예시로 100)

* 이후 응답 데이터를 보낸다. **HTTP/1.1 201 Created**

* 200도 가능 201로 보내면 Location을 보냄 이는 자원이 생성된 PATH를 보내준다.
* 또한 기본적으로 등록된 자원에 대한 데이터도 보낸다.

<br>

### POST는 요청 데이터를 어떻게 처리한다는 뜻일까?

**스펙** : POST메서드는 대상 리소스가 리소스의 고유한 의미 체계에 따라 요청에 포함 된 표현을 처리하도록 요청합니다.

* HTML 양식에 입력 된 **필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공**(HTML FORM)   
게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시(게시판 글쓰기, 댓글 달기)

* 서버가 아직 식별하지 않은 **새 리소스 생성** (신규 주문 생성)

* 기존 자원에 **데이터 추가** (한 문서 끝에 내용 추가)

**정리** : 리소스 URI에 POST요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 한다.

### POST 정리

1. 새 리소스 생성(등록) : 서버가 아직 식별하지 않은 새 리소스 생성

2. 요청 데이터 처리 : 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 프로세스를 처리해야 하는 경우

    >  **예)** : 주문에서 결제완료 -> 배달시작 -> 배달완료 처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우   
    > 즉 POST의 결과로 새로운 리소스가 생성되지 않을 수 도 있다.   

    > **예)** POST/ orders/{orderId}/start-delivery (**컨트롤 URI**)   
      위와 같이 동사의 URI가 나올 수 도 있고 이를 컨트롤 URI라함   
      (리소스로 모든것을 설계할 수 없는 부분도 있다)

3. 다른 메서드로 처리하기 애매한 경우

    > **예)** JSON으로 조회 데이터를 넘기는데, GET메서드를 사용하기 어려운 경우(GET메소드의 메시지 바디를 지원하지 않는 서버가 많음)

    > **예)** 애매하면 POST! (POST는 모든것을 할 수 있다.)   
    (하지만 조회할때는 GET이 유리 예를 들어서버끼리는 약속을 함 GET 요청이 오면 캐싱을 하겠다. 하지만 POST는 캐싱을하기 어려움    
    따라서 조회의 데이터는 최대한 GET을 사용하자)
    
<br><br>

## [HTTP 메서드 : PUT, PATCH, DELETE]

### PUT
* 리소스를 **완전히** 대체
  * 리소스가 있으면 대체, 없으면 생성 (쉽게 이야기해서 덮어버림)
  * 아래와 같은 상황에서 100번 리소스 있으면 신규생성, 있으면 완전히 새로 대체
    ```
    PUT /members/100 HTTP/1.1
    Content-Type: application/json
    {
      "username": "hello",
      "age": 20
    }
    ```
* **중요! 클라이언트가 리소스를 식별**
  * 클라이언트가 리소스 위치를 알고 URI를 지정함
    * /members/100 리소스의 위치를 알고 구체적으로 지정
  * 이것에서 POST와 큰 차이를 보인다.(POST는 100인지 101인지 모르고 /members를 호출)
  > PUT은 두가지를 기억하자
  > 1. 리소스를 대체한다.
  > 2. 클라이언트가 리소스를 알고있어야 한다.

<br>

**PUT 동작 예시**
1. 리소스가 있는 경우
   * 클라이언트에서 보내는 메시지
      ```
      PUT /members/100 HTTP/1.1
      Content-Type: application/json
      {
        "username": "old",
        "age": 50
      }
      ```
   * 만약 기존 /members/100에 username : young, age : 20이라는 리소스가 있었다면
   * 새로 들어온 값으로 대체한다.

2. 리소스가 없는 경우
   * 리소스가 없으면 서버에서 신규 리소스가 생성된다.
*  **리소스를 완전히 대체한다를 알아두자!!**
   *  만약 클라이언트에서 username을 빼고 age필드만 변경하고 서버로 전송해도 username필드가 삭제된다.
   *  왜? 완전히 대체하므로!!
   *  PUT은 리소스의 수정이 아닌 완전히 갈아치우는 것
*  리소스의 수정의도로 사용하기 위해선 PATCH를 사용하면 된다.

<br>

### PATCH : 리소스 부분 변경
* 만약 PATCH로 age : 50만 보내면 기존 username은 날리지 않고 age필드만 부분변경된다.
  * 부분 변경을 위해서는 PATCH를 사용하자

<br>

### DELETE : 리소스를 제거
* DELETE /members/100 HTTP/1.1 이렇게 클라이언트가 서버로 메시지를 보내면
* 서버측이 /members/100을 보고 100을 제거한다.

<br>

### **정리**   
> PUT 완전히 대체, PATCH 부분 변경, DELETE 제거이다.   
> 리소스를 부분변경할떄는 PATCH를 사용할 수 있지만 지원 하지 않는 서버도 존재
> 그런 경우에는 POST를 사용하자

<br><br>

## [HTTP 메서드 : HTTP 메서드의 속성]
* 안전(Safe Methods)
* 멱등(Idempotent Methods)
* 캐시가능(Cacheable Methods)
> HTTP 메서드별 속성 정리 표 : https://ko.wikipedia.org/wiki/HTTP

<br>

### 안전(Safe)
* 호출해도 리소스를 변경하지 않음
* 호출할 때 오류가 발생하는것과 같이 외부적인 장애는 고려하지 않음
* 단지 특정 메소드가 특정 리소스를 변경하는지 여부만 고려한다.

<br>

### 멱등(Idempotante)
* f(f(x)) = f(x)
* 한 번 호출하던, 100번 호출하던 결과는 동일하다.
* 멱등 메소드
  * GET: 여러번 조회해도 동일한 결과
  * PUT: 결과를 대체한다. 하지만 동일한 요청일때 동일한 결과를 반환하므로 멱등
  * DELETE: 결과를 삭제한다. 여러번의 동일요청있을때 동일결과를 반환하므로 멱등
  > POST는 멱등이 아니다 -> 결제 요청을 두 번 한다면 두 번의 결제가 중복되어 발생할 수 있다.
* 멱등 활용
  * 자동 복구 메커니즘
  * 서버가 TIMEOUT등 특정 문제로 인해 정상 응답을 하지 못한 경우, 클라이언트가 동일 요처을   
    다시 해도 되는가의 근거가 된다.

> **[의문]** 요청 중간에 다른 사용자의 요청으로 리소스가 변경된 경우 멱등성은 지켜지는가?   
> -> 멱등은 외부 요인으로 중간에 리소스가 변경되는 부분은 고려하지 않음

<br>

### 캐시가능(Cacheable)
* 응답 결과 리소스를 캐시하여 사용해도 되는지의 여부
* GET, HEAD, POST, PATCH 캐시가능
* 하지만 실제로는 GET, HEAD정도만 캐시로 사용한다.
  * POST, PATCH는 본문(BODY)내용까지 캐시 키로 고려해야 하므로 구현 어려움

<br><br>

## [HTTP 메서드 활용 : 클라이언트에서 서버로 데이터 전송]

### 크게 2가지의 데이터 전달 방식 존재
1. 쿼리 파라미터를 통한 데이터 전송
    * GET
    * 주로 정렬 필터(검색어로 검색할때, 게시판 리스트에 정렬조건 넣을때)
2. 메시지 바디를 통한 데이터 전송
    * POST, PUT, PATCH
    * 회원가입, 상품 주문, 리소스 등록, 리소스 변경과 같은 경우 주로 사용한다.

<br>

### 4가지 상황의 클라이언트->서버 데이터 전송 방법
1. 정적 데이터 조회
    * IMG, 정적 텍스트 문서
2. 동적 데이터 조회
    * 주로 검색, 게시판 목록 정렬 필터(검색어)
3. HTML Form을 통한 데이터 전송
    * 회원 가입, 상품 주문, 데이터 변경
4. HTTP API를 통한 데이터 전송
    * 회원 가입, 상품 주문, 데이터 변경
    * 서버 to 서버, 앱 클라이언트, 웹 클라이언트(Ajax)

<br>

### 1. 정적 데이터 조회(쿼리 파라미터 미사용)
* 쿼리 파라미터 없이 리소스 경로로 단순하게 조회 가능하다. (GET 방식)

<br>

### 2. 동적 데이터 조회(쿼리 파라미터 사용)
* https://www.google.com/search?**q=hello&hi=ko**
* 위의 URL을 서버에 요청하면 서버는 쿼리 파라미터 기반으로 정렬 필터해서 결과를 동적으로 생성한다.
* 주로 조회 조건을 줄여주는 필터, 조회 결과 정렬하는 정렬 조건에 사용된다.
* 조회는 GET방식(쿼리 파라미터 이용하여 데이터 전달)

<br>

### 3. HTML Form 데이터 전송(POST 전송 - 저장)
``` html
  <form action="/save" method="post">
  </form>
```
* HTML Form submit시 POST 전송
  * 예) 회원가입, 상품주문, 데이터 변경 등
* Content-type: application/x-www-form-urlencoded 사용
  * form내용 메시지 바디 통해 전송 (key=value 형식으로 -> 쿼리 파라미터 형석)
  * 전송 데이터를 url encoding 처리 (한글 -> UTF-8과 같이 변경)
* HTML Form은 POST 및 GET 전송도 가능하다.(하지만, GET은 데이터를 저장하는 용도로 사용하면 안됨)
* Content-Type: multipart/form-data
  ``` html
  <form action="/save" method="post" enctype="multipart/form-data">
  </form>
  ```
  * 파일 업로드와 같은 바이너리 데이터도 전송 가능하다.
  * 다른 종류의 여러 파일과 폼의 내용을 함께 전달 가능(multi-part)
> HTML Form 전송은 GET, POST만 지원한다.

<br>

### 4. HTTP API 데이터 전송
* 그냥 직접 API를 만들면 된다. (클라이언트 라이브러리를 보통 이용)
```
POST/ members HTTP/1.1
Content-Type: application/json

{
  "username": "young",
  "age": 20
}
```
* 서버 to 서버
  * 백엔드 시스템 끼리의 통신
* 앱 클라이언트 (아이폰, 안드로이드)
* 웹 클라이언트
  * HTML에서 Form 전송 대신 자바스크립트를 통한 통신에 사용(AJAX)
  * 예) React, VueJs 같은 웹 클라이언트와 API 통신
* POST, PATCH, PUT: 메시지 바디를 통해 데이터 전송
* GET: 조회, 쿼리 파라미터로 데이터 전송
* Content-Type은 application/json을 주로 사용 (사실상 표준)
  * 외에도 XML, TEXT도 가능

<br><br>

## [HTTP 메서드 활용 : HTTP API 설계 예시]
* HTTP API - 컬렉션
  * POST 기반 등록
  * 예) 회원 관리 API 제공
* HTTP API - 스토어
  * PUT 기반 등록
  * 예) 정적 컨테츠 관리, 원격 파일 관리
* HTML FORM 사용
  * 웹 페이지 회원 관리
  * GET, POST만 지원

<br>

### 1-1. 회원 관리 시스템(API 설계 - POST 기반 등록)
* 회원 **목록** /members -> **GET**
  * 회원 조회할때 회원수가 너무 많다면 쿼리 파라미터를 이용해 검색어, 정렬할 수 있음
* 회원 **등록** /members -> **POST**
* 회원 **조회** /members/{id} -> **GET**
* 회원 **수정** /members/{id} -> **POST**, **PUT**, **PATCH**
  * 어떤 것을 사용할지 고민을 해야함
  * 회원 데이터 수정은 개념적으로 **PATCH**(부분 수정) 사용을 권장   
    (클라이언트에서 완전히 덮어도 문제 없다면 PUT사용도 괜찮음)
  * 만약 게시판의 게시글을 수정하는 경우 PUT을 사용할 수 도 있다.
  * 둘 다 애매하다면 POST를 사용
* 회원 **삭제** /members/{id} -> **DELETE**
> 리소스 식별을 잘해야함 (미네랄을 캐다 -> 미네랄이 리소스)   
> /members와 같은 회원 관리 URL을 **컬렉션** 이라고 한다. -> 복수의 개념

<br>

### 1-2. 회원 관리 시스템(POST - 신규 자원 등록 특징)
* 클라이언트는 등록될 리소스의 URI를 모름.
  * 회원 등록 /members -> POST
  * POST /members
* 서버가 새로 등록된 리소스 URI를 생성해준다.
  * HTTP/1.1 201 Created   
    Location: /members/100
* 컬렉션(Collection)
  * 서버과 관리하는 리소스 디렉토리
  * 서버가 리소스 URI를 생성하고 관리
  * 여기서 컬렉션은 /members
> **중요 : POST 방식은 서버가 신규 URI(리소스)를 생성하고 관리한다.**   
> 응답시 Location을 넘기거나 "id": {id}로 넘기기도 한다.

<br>

### 2-1. 파일 관리 시스템(API 설계 - PUT 기반 등록)
* 파일 **목록** /files -> **GET**
* 파일 **조회** /files/{filename} -> **GET**
* 파일 **등록** /files/{filename} -> **PUT**
  * 파일이 없다면 새로 생성, 있다면 덮어버림
  * 파일을 관리하는 경우 PUT이 알맞다.
* 파일 **삭제** /files/{filename} -> **DELETE**
* 파일 **대량 등록** /files -> **POST**
  * PUT이 파일 등록이므로 /files에 대한 POST의 의미를 임의로 정할 수 있다.

<br>

### 2-2. 파일 관리 시스템(PUT - 신규 자원 등록 특징)
* 클라이언트가 리소스 URI를 미리 알고 있어야 한다.
  * 파일 등록 /files/{filename} -> PUT
  * PUT /files/something.jpg
* 클라이언트가 직접 리소스의 URI를 지정한다.
* 스토어(Store)
  * 클라이언트가 관리하는 리소스 저장소
  * 클라이언트가 리소스의 URI를 알고 관리
  * 여기서 스토어는 /files
> **중요 : PUT 방식은 클라이언트가 신규 리소스의 URI를 미리 알고, 지정하여 등록한다.**   
> 이런 스타일의 관리를 **Store** 라고 한다. (/files)

> 주로 POST 기반의 신규 자원 등록을 많이 사용한다. (Collection)

<br>

### 3-1. HTML FORM 사용
* GET, POST만 지원   
  (위의 제한 사항은 AJAX 같은 기술을 사용해서 해결 가능 - 회원 API 참고)
* 순수 HTML, HTML FORM을 알아보자    
  (GET, POST만 사용하도록 제약)

<br>

### 3-2 HTML FORM 설계
* 회원 **목록** /members -> **GET**
* 회원 **등록 폼** /members/new -> **GET**
* 회원 **등록** /members/new, /members -> **POST**
  * 2가지 선택지 존재
  * Validation으로 POST시 문제 발생해 POST의 최종 결과를 다시 폼으로 넘겨주는 경우가 존재함   
    이럴때 /members로 넘어가면 form으로 돌아갈 수 없음 따라서 /members/new 추천
* 회원 **조회** /members/{id} -> **GET**
* 회원 **수정 폼** /members/{id}/edit -> **GET**
  * form 자체를 보는것은 변경되는것이 아님
* 회원 **수정** /members/{id}/edit, /members/{id} -> **POST**
  * /members/{id}/edit의 방식을 추천(Validation)
* 회원 **삭제** /members/{id}/delete -> **POST**
  * DELETE를 사용할 수 없으므로 /delete라는 Control URI를 사용   
    (Controller라고도 함)

<br>

### 3-3 HTML FORM 정리
* HTML FORM은 GET, POST만 지원
* **컨트롤 URI**
  * GET, POST만 지원되므로 제약 존재
  * 제약을 해결하기 위한 동사형 리소스 경로 사용
  * POST의 /new, /edit, /delete가 컨트롤 URI
  * HTTP 메서드로 해결하기 애매한 경우 사용(HTTP API 포함)
  > **중요 : 최대한 리소스라는 개념을 가지고 URI를 설계하고, 그 상황에서 안될때   컨트롤 URI를 대체제로 사용한다.**   

  > HTTP API설게에서도 HTTP 메서드로 전부 맞아떨어지지 않음 따라서, 이런 경우에서도 컨트롤 URI를 사용한다.

<br>

### [정리]
* HTTP API - 컬렉션(**POST** 기반 등록)
  * 서버가 리소스 URI 결정
* HTTP API - 스토어(**PUT** 기반 등록)
  * 클라이언트가 리소스 URI 결정
* HTML FORM 사용
  * 순수 HTML + HTML Form 사용
  * GET, POST만 지원

<br>

### [정리] - 참고하면 좋은 URI 설계 개념
* **문서(Document)**
  * 단일(단수) 개념(파일 하나, 객체 인스턴스, 데이터베이스 row)
  * 예) /members/100, /files/star.jpg
* **컬렉션(Collection)**
  * 복수의 개념
  * 서버가 관리하는 리소스 디렉터리
  * 서버가 리소스의 URI를 생성하고 관리
  * 예) members/
* **스토어(Store)**
  * 복수의 개념
  * 클라이언트가 관리하는 자원 저장소
  * 클라이언트가 리소스의 URI를 알고 관리
  * 예) files/
* **컨트롤러(Controller), 컨트롤 URI**
  * 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
  * 동사를 직접 사용
  * HTML FORM 뿐 아니라 HTTP API 에서도 많이 활용된다.
    * HTTP API ex) 회원의 주문의 상태를 다음단계로 진행
  * 예) /members/{id}/delete
  * 컨트롤 URI를 사용하는 기준
    * 먼저 리소스만을 이용해 리소스 URI를 설계한다.
    * 상세는 /members/{id}와 같이 설계를 한 다음
    * 이것만 가지고 해결이 안되는 상황에서 **컨트롤 URI**를 이용한다.
      * 즉, 컬렉션, 문서를 가지고 최대한 GET, POST, PUT, DELETE를 가지고 최대한 해결을 한다.
      * 그게 안된다면 컨트롤 URI이용 
> RESTFUL API 좋은 예시들 참고 사이트 : https://restfulapi.net/resource-naming

<br><br>

# [HTTP 상태코드]
## |1. 상태코드 소개|
상태코드 : 클라이언트가 보낸 요청의 처리 상태를 응답(response)에서 알려주는 기능
* 1xx(Informational): 요청이 수신되어 처리 중 (거의 사용되지 않음)
* 2xx(Successeful): 요청 정상 처리
* 3xx(Redirection): 요청을 완료하려면 추가 행동이 필요
* 4xx(Client Error): 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
* 5xx(Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함
> xx부분은 여러가지가 존재하지만 크게 상위의 5가지의 숫자로 요청의 상태를 위와같이 판단한다.

<br>

### 만약 모르는 상태코드가 나타나면?
* 클라이언트가 인식할 수 없는 상태코드를 서버가 반환한다면, 클라이언트는 상위코드로 해석해서 처리
* 새로운 상태코드가 추가되어도 클라이언트를 변경하지 않아도 됨.
  * 299 : ??? -> 2xx(Successeful)
  * 451 : ??? -> 4xx(Client Error)
  * 599 : ??? -> 5xx(Server Error)

<br>

## |2. 2xx - Successeful|
클라이언트의 요청을 성공적으로 처리
* **200 OK**
  * 서버에서 결과를 정상적으로 잘 처리해서 응답하면 200 OK (GET 요청 정상 처리시 발생)
* **201 Created** 
  * 클라이언트의 요청을 가지고 서버쪽에서 신규 리소스가 생성됐을때 201로 응답   
    (주로 POST로 등록 했을떄 이용)
  * 생성된 리소스는 응답의 Location 헤더 필드로 식별한다.   
    (Location: /members/100)
* **202 Accepted**
  * 요청이 접수되었으나 처리가 완료되지 않았음
  * 배치 처리 같은 곳에서 사용   
    예) 요청 접수 후 1시간 뒤에 배치 프로세스가 요청을 처리함
* **204 No Content**
  * 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문(Body)에 보낼 데이터가 없음
  * 예) 웹 문서 편집기에서 save 버튼   
    save 버튼의 결과로 아무 내용 없어도 됨
    버튼을 눌러도 같은 화면이 유지되어야 한다.   
    결과내용이 없어도 204 메시지(2xx)만으로 성공을 인식할 수 있다.

<br>

## |3. 3xx - Redirection|
요청을 완료하기 위해 유저 에이전트(클라이언트 프로그램 즉, 웹브라우저를 말함)의 추가 조치 필요
* **300 Multiple Choices** (거의 사용되지 않음)
* **301 Moved Permanently**
* **302 Found**
* **303 See Other**
* **304 Not Modified**
* **307 Temporary Redirect**
* **308 Permanent Redirect**

### 리다이렉션 이해
* 웹 브라우저는 3xx 응답의 결과에 Location헤더가 있으면, Location 위치로 자동 이동(리다이렉트)

* 자동 리다이렉션 흐름
  * /event URL이 오래된 이벤트 페이지라서 사용하지 않는 경로이며, /new-event로 변경되었으면
  * /event요청시 서버는 301 Moved Permanently과 새로운 경로를 Location: /new-event로 전달
  * 이후 Location의 경로를 이용해 웹 브라우저가 /new-event를 처음부터 다시 요청함

* 리다이렉션의 종류
  1. **영구 리다이렉션** - 특정 리소스의 URI 영구적으로 이동
      * 예) /event -> /new-event
  2. **일시 리다이렉션** - 일시적인 변경
      * 주문 완료 후 주문 내역 화면으로 이동
      * PRG : Post/Redirect/Get
  3. **특수 리다이렉션**
      * 결과 대신 캐시를 사용
      * 예) 클라이언트가 사용하려는 캐시가 만료된것 같아 서버에 확인 요청을 보냄
        그대로 사용해도 되는 캐시라면, 캐시에서 다시 조회하라는 응답을 보냄


### 영구 리다이렉션(301, 308)
* 리소스의 URI가 영구적으로 이동
* 원래의 URI를 사용 X, 검색 엔진 등에서도 변경 인지
* **301 Moved Permanently**
  * 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음(MAY)
  > 될 수 있는 이유는 초기 스펙은 POST로 리다이렉트 할 줄 알고 그렇게 만듦
* **308 Permanent Redirect**
  * 301과 기능은 같음
  * 리다이렉트시 요청 메서드와 본문 유지함(처음 요청이 POST면 리다이렉트도 POST 요청)

<br>

### 일시적인 리다이렉션(302, 307, 303)
* 리소스의 URI가 일시적으로 변경
* 따라서 검색 엔진 등에서 URL을 변경하면 안됨.
* **302 Found**
  * 리다이렉트시 **요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음**(**MAY**)
  * 주로 많이 사용된다.
* **307 Temporary Redirect**
  * 302와 기능은 같음
  * 리다이렉트시 **요청 메서드와 본문 유지**(요청 메서드를 변경하면 안된다. **MUST NOT**)
* **303 See Other**
  * 302와 기능은 같음
  * 리다이렉트시 **요청 메서드가 GET으로 변경** (본문제거 됨)

### PRG: Post/Redirection/Get 일시적인 리다이렉션의 예시
* 주문 페이지서 POST로 특정 상품을 주문 후 웹 브라우저를 새로고침하면 동일한 주문이 또 입력될 수 도있다.
* 서버측에서도 동일 주문은 막겠지만, 클라이언트에서도 막을 수 있는 방법이 PRG를 이용한다.
* POST로 주문후에 새로 고침으로 인한 중복을 방지한다.
  1. POST로 주문
  2. 주문 후 결과화면을 GET 메서드로 리다이렉트
  3. 따라서 주문 완료 화면에서 새로고침을 해도 결과화면을 요청하므로 중복 주문을 방지할 수 있다.
  4. URL이 **POST -> GET**으로 리다이레트 되므로 새로고침해도 GET 결과화면만 조회됨(사용성이 좋다.)

<br>

### 정리 (무엇을 써야하나?)
* 302 Found -> GET으로 변할 수 있음
* 307 Temporary -> 메서드가 변하면 안됨
* 303 See Other -> 메서드가 GET으로 변경   

**[초기]**
> 처음 302스펙의 의도는 HTTP 메서드를 유지하는 것이나   
> 웹 브라우저들이 대부분 GET으로 변경하여 사용함
> 따라서 모호한 302대신 303, 307같이 명확한 스펙 등장(301대응으로 308)

**[현실]**   
> 307, 303을 권장하지만, 현실적으로 302를 대부분 사용하고 있음   
> 따라서 자동 리다이렉션시 GET으로 변경해도 된다면 302사용 무방함

### 기타 리다이렉션(300, 304)
* 300 Multiple Choices: 사용 X
* **304 Not Modified**
  * 캐시를 목적으로 사용됨
  * 클라이언트에게 리소스가 수정되지 않았음을 알려줌, 따라서 클라이언트는 로컬 PC에 저장된   
    캐시를 재사용함(캐시로 리다이렉트함)
  * 304응답은 응답에 메시지 바디 포함하면 안됨 (로컬 캐시 사용을 위해)
  * 조건부 GET, HEAD 요청시 사용된다.

<br>

## |4. 4xx - Client Error, 5xx - Server Error|

### 4xx (Client Error)
* 클라이언트의 요청에 잘못된 문법등으로 서버가 요청을 수행할 수 없음
* 오류의 원인은 클라이언트에게 있다.
* **중요! 클라이언트가 이미 잘못된 요청, 데이터를 보내고 있으므로, 똑같은 재시도는 무조건 실패**
  > **[5xx와의 차이점]** : 5xx는 서버의 오류로 발생됨   
  > 만약 DB서버 다운이 원인이라면 DB서버가 복구되고 동일한 재요청을 하면 **성공 할 가능성이 있다.**   
  > 이 부분에서 4xx, 5xx는 차이를 보인다.

<br>

### 400 Bad Request
**클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음**
* 요청 구문, 메시지 등등 오류
* 클라이언트는 요청 내용을 다시 검토하고, 보내야함
* 예) 요청 파라미터가 잘못되거나, API 스펙이 맞지 않을 때

### 401 Unauthorized
**클라이언트가 해당 리소스에 대한 인증이 필요함**
* 인증(Authentication) 되지 않음
* 401 오류 발생시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명
> **인증 (Authentication)**: 본인이 누구인지 확인(로그인)   
> **인가 (Authorization)**: 권한 부여 (Admin 권한처럼 특정 리소스에 접근할 수 있는 권한, 인증이 있어야 인가가 있다.)
   
> 오류내용은 인증(Authentication)이 되지 않았지만 401이름이 Unauthorized임 작명의 아쉬움이 있다.

### 403 Forbidden
**서버가 요청을 이해했지만 승인을 거부함**
* 주로 인증 자격은 있지만, 접근 권한(인가)이 불충분한 경우
* 예) 관리자 등급이 아닌 사용자가 로그인은 했으나, 관리자 등급 리소스에 접근하는 경우 발생

### 404 Not Found
**요청 리소스를 찾을 수 없음**
* 요청 리소스가 서버에 없음
* 또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을 때

<br>

### 5xx (Server Error)
* 서버 문제로 오류 발생
* 서버에 문제 있으므로 재시도 하면 성공할 수 있다.(서버 복구 등)
* ex) NPE, 데이터베이스 접근 불허 등 ㅠ

### 500 Internal Server Error
**서버 문제로 오류 발생, 애매하면 500오류**
* 서버 내부 문제로 오류 발생됨
* 애매하면 500오류

### 503 Service Unavailable
**서비스 이용 불가**
* 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음
* Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼 수 있다.

<br>

**[정리]**
* 4xx: 클라이언트에서 잘못함 (스펙을 잘못맞추거나, 인증이 안됨)
* 5xx: 서버 내부에 문제가 있음
* **유의할점**
  * 5xx에러는 웬만하면 서버에서는 만들면 안된다. **5xx는 정말 서버에 문제가 생겼을때 응답할 수 있게 해야한다.**
  * 예) API 스펙, 서버까지 정상일때 고객이 잔고가 부족한 경우   
    이럴때는 5xx에러를 발생시키면 안된다. -> 서버에 정말 문제가 있는것이 아니라 비즈니스 로직의 예외케이스 이므로

    
<br>

# [HTTP 헤더1]
## |1. HTTP 헤더 개요|
### 용도
* HTTP 전송에 필요한 모든 부가정보
* 예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 관리정보 등
* 표준 헤더 매우 많음
  * https://en.wikipedia.org/wiki/List_of_HTTP_header_fields
* 필요시 임의의 헤더 추가 가능
  * 예) helloworld: hihi

<br>

### 분류 - RFC2616(과거 1999년)
* 헤더의 분류
  * **General 헤더**: 메시지 전체에 적용되는 정보, 예) Connection: close
  * **Request 헤더**: 요청 정보, 예) User-Agent: Mozilla/5.0 (Macintosh); ..)
    * Request시 현재 브라우저의 정보 등 전달
  * **Response 헤더**: 응답 정보, 예) Server: Apache
    * Response시 현재 서버의 정보 등 전달
  * **Entity 헤더**: 엔티티 바디 정보, 예) Content-Type: text/html, Content-Length: 3423

### HTTP BODY message body - RFC2616(과거)
* 메시지 본문(message body)은 엔티티 본문(entity body)을 전달하는데 사용
* 엔티티 본문은 요청이나 응답에서 전달할 실제 데이터(메시지 본문안에 엔티티 본문을 담아 전달)
* **엔티티 헤더**는 **엔티티 본문**의 데이터를 해석할 수 있는 정보 제공
  * 데이터 유형(html, json), 데이터 길이, 압축 정보 등

<br>

### 새로운 스펙 RFC7230 ~ 7235 등장
* 엔티티(Entity) -> 표현(Representation)
* Representation = Representation Matadata(표현 메타데이터) + Representation Data(표현 데이터)

### HTTP BODY message body
* 메시지 본문(message body)을 통해 표현 데이터 전달
* 메시지 본문 = 페이로드(payload)
* **표현**은 요청이나 응답에서 전달할 실제 데이터 (표현 헤더 + 표현 데이터)
*** 표현 헤더는 표현 데이터**를 해석할 수 있는 정보 제공
  * 데이터 유형(html, json), 데이터 길이, 압축 정보 등등
* 참고: 표현 헤더는 표현 메타데이터와, 페이로드 메시지를 구분해야 하지만, 생략
> **[왜 표현이라 말할까?]**   
> 특정 리소스를 html, json등 여러가지로 표현하여 전달 할 수 있으므로 표현이라고 정의함   
> **[Representation의 R이 REST의 R]**   

> **[표현 메타데이터]**: 표현의 항목 중 표현 데이터를 해석할 수 있는 정보를 제공하는 것을 표현 메타데이터라함

<br>

## |2. 표현|
### 종류
회원 리소스를 HTML 표현, JSON 표현으로 전송하려 할 때의 표현의 의미와 동일   
데이터를 전달할 때 특정 표현으로 변경해 전달하는것

* Content-Type: 표현 데이터의 형식
* Content-Encoding: 표현 데이터의 압축 방식
* Content-Language: 표현 데이터의 자연 언어
* Content-Length: 표현 데이터의 길이
  > 실제론 표현 데이터의 길이는 표현과 무관한 의미가 되므로, 페이로드 헤더라고 구분됨
* 표현 헤더는 전송, 응답 둘 다 사용

### Content-Type: 표현 데이터의 형식 설명
* 미디어 타입, 문자 인코딩
* 예)
  * text/html; charset=utf-8
  * application/json  (기본이 utf-8)
  * image/png

### Content-Encoding: 표현 데이터 인코딩
* 표현 데이터를 압축하기 위해 사용
* 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가
* 데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제
* 예)
  * gzip
  * deflate
  * identity (압축 안한다.)

### Content-Language: 표현 데이터의 자연 언어
* 표현 데이터의 자연 언어를 표현
* 예)
  * ko
  * en
  * en-US

### Content-Length: 표현 데이터의 길이
* 바이트 단위
* Transfer-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안됨
  * Transfer-Encoding안에 Content-Length와 같은 정보들이 들어있으므로

<br> 

## |3. 콘텐츠 협상(Contents Negotiation)|
클라이언트가 선호하는 표현 요청   
* Accept: 클라이언트가 선호하는 미디어 타입 전달
* Accept-Charset: 클라이언트가 선호하는 문자 인코딩
* Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
* Accept-Language: 클라이언트가 선호하는 자연 언어
> **협상 헤더는 요청시에만 사용**

> **ex) Accept-Language의 역할**   
> 다중 언어 지원 서버(en, ko)가 미국 사이트라면 기본 언어는 en   
> 한국어 브라우저에서 요청을 보내면 Content-Language: en으로 서버가 응답한다(default)   
> 하지만 Accept-Language: ko를 같이 요청에 보내게 되면 서버는 다중언어를 지원하므로 한국어로 응답한다.

### 협상과 우선순위1 Quality Values(q)
만약 다중 언어 지원 서버가 영어, 독일어만 지원할 때 Accept-Language: ko를 전달하면 서버는   
한국어를 지원하지 않으므로 응답할 수 없음   
이런 경우를 대비해 우선순위를 두어 차선책인 영어를 전달받을 수 있게 함


* Quality Values(q)값 사용
* 0~1, **클수록 높은 우선수위**
* 생략하면 1
* GET /event   
  Accept-Language: ko-KR, ko;q=0.9,en-US;q=0.8,en;q=0.7
    1. ko-KR;q=1 (q생략)
    2. ko;q=0.9
    3. en-US;q=0.8
    4. en;q=0.7

위와같이 보내게 된다면 한국어를 지원하지 않는다면 서버는 그 다음 우선순위인 영어를 선택해 응답하게 된다.

### 협상과 우선순위2
GET /event   
Accept: text/*, text/plain, text/plain;format=flowed, */\*
* 구체적인 것이 우선한다.
    1. text/plain;format=flowed
    2. text/plain
    3. text/*
    4. */\*

### 협상과 우선순위3 Quality values(q)
* 구체적인 것을 기준으로 미디어 타입을 맞춘다.
* Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1, texxt/html;level=2;q=0.4, */\*;q=0.5
   
  |Media Type|Quality|
  |---------------------------|----|
  |text/html;level=1|1|
  |text/html|0.7|
  |text/palin|0.3|
  |images/jpeg|0.5|
  |text/html;level=2|0.4|
  |text/html;level=3|0.7|

<br>

## |4. 전송 방식|
* Transfer-Encoding
* Range, Content-Range

### 전송 방식 설명
* 단순 전송
* 압축 전송
* 분할 전송
* 범위 전송

### 단순 전송 Content-Length
* 요청을하면 응답을 주는데 메시지 바디에서 대한 Content-Length를 지정해준다.
* 즉 길이 값을 앎

### 압축 전송 Content-Encoding
* 서버에서 gzip과 같은것으로 압축하여 전송함
* 이런 경우에는 Content-Encoding을 같이 보내줘야 한다.

### 분할 전송 Transfer-Encoding
* Transfer-Encoding: chunked(덩어리)
* 메시지 바디를 나누어서 전송한다. 전송이 끝난다면 0 \r\n을 전송
* 용량이 매우 큰 경우 분할하여 전송할 때 사용한다.
* 분할 전송시에는 Content-Length를 넣으면 안된다.
  * Content-Length가 초기에 예상이 안됨
  * 또한 chunked마다 바이트 정보가 있으므로 보내지 않아야 함

### 범위 전송 Range, Content-Range
* Content-Range: bytes 1001-2000 / 2000
* 기존에 파일을 다운받다가 끊겼다면 다시 다운 받을때 이어 받기할 때 사용되기도 함

<br>

## |5. 일반 정보|
* From: 유저 에이전트의 이메일 정보
* Referer: 이전 웹 페이지 주소
* User-Agent: 유저 에이전트 애플리케이션 정보
* Server: 요청을 처리하는 오리진 서버의 소프트웨어 정보
* Date: 메시지가 생성된 날짜

### From: 유저 에이전트의 이메일 정보
* 일반적으로 잘 사용되지 않음(크롤링시 우리 사이트 이용하지 말라고 알리고 싶을때)
* 검색 엔진 같은 곳에서, 주로 사용
* 요청에서 주로 사용

### Referer: 이전 웹 페이지 주소
* 현재 요청된 페이지의 이전 웹 페이지 주소
* A -> B로 이동할 때, B를 요청할 때 Referer: A를 포함해서 요청
* Referer를 사용해서 유입 경로 분석 가능
* 요청에서 사용
* referrer의 오타이다.
  
### User-Agent: 유저 에이전트 애플리케이션 정보
  * 클라이언트의 애플리케이션 정보(웹 브라우저 정보, 등등)
  * 특정 브라우저에서만 생기는 버그를 파악할 수 있다. (로그 파싱하여)
  * 통계정보 뽑기 좋음
  * 요청에서 사용

### Server: 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보
HTTP 요청을 보내면 중간에 여러 프록시 서버를 거치게 된다.   
실제 나의 요청이 도착해 HTTP응답을 해주는 진짜 서버를 ORIGIN Server라고 한다.
* 응답에서 사용된다.

### Date: 메시지가 발생한 날짜와 시간
* 응답에서 사용된다.

<br>

## |6. 특별한 정보|
특별한 정보를 제공하는 헤더이다.   
Host, Location, Allow, Retry-After

### Host: 요청한 호스트 정보(도메인)
* 요청에서 사용
* 필수 헤더임 (매우 중요)
* 하나의 서버가 여러 도메인을 처리해야 할 때 구분해준다.
* 하나의 IP 주소에 여러 도메인이 적용되어 있을 때

* 예제
  * 가상호스트를 통해 여러 도메인을 한번에 처리할 수 있는 서버(실제 애플리케이션이 여러개 구동될 수 있다.)
  * 만약 Host가 없다면 특정 요청을 보내게 되면 aaa.com, bbb.com, ccc.com중   
    어느 애플리케이션에 들어가야할 지 구분하지 못한다.
  * Host: aaa.com으로 헤더를 넣어주면 Host헤더를 가지고 서버 내부에서 aaa.com으로 가상호스팅 해준다.

### Location: 페이지 리다이렉션
* 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동(리다이렉트)
* 201 (Created): Location 값은 요청에 의해 생성된 리소스 URI (201도 사용 가능하다.)
* 3xx (Redirection): Location 값은 요청을 자동으로 리다이렉션 하기 위한 대상 리소스 가리킴

### Allow: 허용 가능한 HTTP 메서드
URL 경로는 있지만, POST 메소드를 지원하지 않는 경우
* 405 (Method Not Allowed) 에서 응답에 포함함
* Allow: GET, HEAD, PUT (POST는 허락되지 않음)

### Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
* 503 (Service Unavailable): 서비스가 언제까지 불능인지 알려줄 수 있음
* 날짜를 표기하거나 초단위로 표기함

<br>

## |7. 인증|
* Authorization: 클라이언트 인증 정보를 서버에 전달
* WWW-Authenticate: 리소스 접근시 필요한 인증 방법 정의

### Authorization: 클라이언트 인증 정보를 서버에 전달
* 클라이언트 인증은 여러가지 매커니즘이 존재하고 종류마다 value에 들어가는 값이 다르다.
* Authorization: Basic xxxxxxxxxxxxxxxx
  
### WWW-Authenticate: 리소스 접근시 필요한 인증 방법 정의
* 리소스 접근시 필요한 인증 방법 정의
* 401 Unauthorized 응답과 함께 사용
* WWW-Authenticate: Newauth realm="apps", type=1, title="Login to \\"apps\\"", Basic realm="simple"
* 인증을 하려면 위와같은 정보를 참고해서 제대로된 인증정보를 만들라는 정보를 서버에서 클라이언트로 반환한다.

<br>

## |8. 쿠기|
* Set-Cookie: 서버에서 클라이언트로 쿠키 전달(응답)
* Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달

### Stateless와 쿠키의 필요성
* HTTP는 무상태 프로토콜
* 클라이언트와 서버가 요청, 응답을 주고 받으면 연결 끊어짐
* 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못한다.
* 클라이언트와 서버는 서로 상태를 유지하지 않는다.

<br>

* 쿠키를 사용하기 이전 로그인을 한 이후 재 요청을 하면 서버는 로그인을 인식하지 못함
* 그렇다면 모든 요청에 사용자 정보를 넘긴다면?
  * 보안 등 여러 문제 발생
  * 브라우저를 완전히 종료하고 다시 열면?

### 쿠키의 생성
* 클라이언트가 로그인 정보를 서버로 넘김(user=홍길동)
* 서버는 Set-Cookie: user=홍길동 이라는 정보를 응답한다.
* 웹 브라우저는 쿠키 저장소에 user=홍길동 정보를 저장한다.
### 쿠키의 사용
* 로그인 이후 welcome 페이지 접근
  * 이전과 동일한 페이지에 접속하면 웹 브라우저는 자동으로 쿠키 저장소를 뒤져서 쿠키 값을 무조건 꺼낸다.
  * Cookie: user=홍길동 을 가지고 서버에 요청을 보낸다.
* 서버는 이를 확인하고 로그인에 맞게 응답한다.
* **쿠키는 모든 요청에 쿠키 정보 자동적으로 포함한다.**

<br>

### 쿠키
정말 모든곳에 쿠키 정보를 보내면 보안등 여러가지 문제가 있으므로 제약해야함
* 예) set-cookie: sessionId=abcd1234; expires=Sat, 26-Dec-2020 00:00:00 GMT; path=/; domain=.google.com; Secure
* 주 사용처
  * 사용자 로그인 세션관리(사용자 정보를 그대로 내리기 보단, session key를 이용해 인증할 수 있도록 함
  * 광고 정보 트래킹 
* 쿠키 정보는 항상 서버에 전송됨
  * 네트워크 트래픽 추가 유발됨
  * 따라서 최소한의 정보만 사용(세션 ID, 인증 토큰)
  * 서버에 전송하지 않고, 웹 브라우저 내부에 데이터 저장 원하면, 웹 스토리지(localStorage, sessionStroage) 참고
* 주의!
  * **보안에 민감한 데이터는 저장하면 안됨(주민번호, 신용카드 정보 등)**

### 쿠키 - 생명주기 Expires, max-age
* Set-Cookie: **expires**=Sat, 26-Dec-2020 00:00:00 GMT(GMT 기준으로 넣어야함)
  * 만료일이 되면 자동 쿠키 삭제
* Set-Cookie: **max-age**=4600 (4600초)
  * 0이나 음수를 지정하면 쿠키 삭제
* 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지
* 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지만 유지된다.

### 쿠키 - 도메인 Domain
내가 지정한 쿠키가 아무 사이트에서나 생성되면 큰일 나므로 도메인을 지정할 수 있다.
* 예) doamin=example.org
* **명시: 명시한 문서 기준 도메인 + 서브 도메인 포함**
  * domain=example.org를 지정해서 쿠키 생성하면
  * example.org는 물론이고
  * dev.example.org도 쿠키 접근 가능
* **생략: 현재 문서 기준 도메인만 적용**
  * example.org에서 쿠키를 생성하고 domain 지정을 생략하면
    * example.org에서만 쿠키 접근 가능하고
    * dev.example.org는 쿠키 미접근

### 쿠키 - 경로 Path
도메인으로 필터하고 경로로 추가 필터를 함
* 예) path=/home
* **이 경로를 포함한 하위 경로 페이지만 쿠키 접근 가능**
* **일반적으로 path=/ 루트로 지정**
* 예)
  * **path=/home 지정**
  * /home -> 가능
  * /home/level1 -> 가능
  * /home/level1/level2 -> 가능
  * /hello -> 불가능

### 쿠키 - 보안 Secure, HttpOnly, SameSite
* **Secure**
  * 쿠키는 원래 http, https 구분하지 않고 전송한다.
  * Secure 적용시 https인 경우에만 전송함
* **HttpOnly**
  * XSS 공격 방지용
  * 자바스크립트에서 접근 불가(document.cookie)
  * HTTP 전송에만 사용
* **SameSite**
  * XSRF 공격 방지
  * 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송

<br><br>

# [HTTP 헤더2 - 캐시와 조건부 요청]
## |1. 캐시 기본 동작|
### 캐시가 없을 때 : 첫 번째 요청
1. GET /star.jpg -> 요청   
2. 1.1M정도(HTTP 헤더: 0.1M, 바디 : 1.0M)가 클라이언트로 전송됨
3. 다시 GET /star.jpg 요청하게 되면 서버는 똑같이 1.1M 이미지를 전송함

* 데이터가 변경되지 않아도 계속 네트워크를 통해 데이터를 다운받음
* 속도 저하, 사용자 불편, 비용 문제(인터넷 네트워크는 느리고 비쌈)

### 캐시 적용 : 첫 번째 요청
1. GET /star.jpg요청
2. HTTP 헤더에 cache-control: max-age=60을 포함해 1.1M 사진 전송
    * 60초 동안은 캐시가 유효
3. 웹 브라우저 캐시 저장소에 응답 결과를 저장한다.(60초의 유효기간)
4. 이후 GET /star.jpg를 60초안에 요청하면 유효 시간 검증 이후, 캐시 저장소에서 가져온다.\
  
* 캐시 덕분에 캐시 가능 시간동안 네트워크 사용X (비싼 사용량 줄임)
* 로딩 속도 UP, 사용자 편의성 증가

**만약 캐시 시간 초과 이후 요청한다면?**
1. GET /star.jpg
2. 서버는 다시 동일한 메시지 cache-control에 max-age를 설정하고 보내줌
3. 응답 결과를 다시 웹 브라우저 캐시에 덮어씌우고 초기화 시킴(다시 60초 유효기간 가지게 됨)

* 캐시 유효 시간이 지난다면, 서버 통해 다시 데이터 조회하고 캐시를 갱신함
* 이때 다시 네트워크 비용이 든다(재 다운로드)

### 캐시 시간 초과
* 캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고 캐시 갱신함
* 만약에 캐시가 만료되고 클라이언트와 서버가 가진 데이터가 동일하면 파일을 다시 다운로드 받아야할까?
  > **다른 방안을 고민해볼 필요가 있다.**

<br>

## |2. 검증 헤더와 조건부 요청1|
### 캐시 시간 초과
* 캐시 유효 시간 초과 이후, 서버에 다시 요청하면 아래 두가지 상황이 나타남
    1. 서버에서 기존 데이터를 변경함
    2. 서버에서 기존 데이터를 변경하지 않음
    > 2번 같은 경우는 다시 재 다운로드 받기에는 비효율적이고, 비용이 크다.  

* 2번 같은 경우는 캐시 만료후에도 서버에서 데이터를 변경하지 않는다.
  * 기존에 저장한 캐시를 재사용할 수 있으므로
  * 다만 클라이언트의 데이터, 서버의 데어터가 같다는 사실을 확인할 수 있어야 한다.
  * 사실 확인을 위해 검증헤더를 추가한다.

### 검증 헤더 추가
첫 번째 요청
1. 클라이언트의 요청은 동일하나 서버의 응답시 cache-control: max-age=60을 추가
2. 추가로 Last-Modified라는 데이터 최종 수정일도 같이 전달한다.
3. 클라이언트는 캐시를 브라우저 캐시에 저장한다.

두 번째 요청 - 캐시 시간 초과
1. GET /star.jpg로 요청을 보낼때 캐시 브라우저에 캐시가 존재하지만 만료됐다면   
   캐시가 가지고 있는 데이터 최종 수정일을 같이 보낸다. **if-modified-since: [날짜]**
2. 서버가 가지고 있는 데이터 최종 수정일과, 요청을 받은 데이터 최종 수정일 날짜가 동일하다면   
   **HTTP 응답을 304 Not Modified**를 보낸다.
3. 추가로 cache-control, Last-Modified를 동일하게 전달하지만 **HTTP Body를 제외하고 보낸다.**   
   이렇게 되면 0.1M만 전달하므로 네트워크 부하가 줄어듦
4. 클라이언트는 HTTP 상태코드를 확인함, 304 Not Modified이므로 캐시를 재사용 해도 된다 판단하고,   
   응답 결과를 재사용, 헤더 데이터 갱신한다.(cache-control값 등)

> 검증헤더와 조건부 요청을 동시에 사용함   
> **검증헤더**: **Last-Modified**   
> **조건부 요청**: **if-modified-since**   
> 위 두개를 조합해 캐시가 정말 갱신 됐는지 확인할 수 있다.

### 정리
* 캐시 유효 시간 초과해도, 서버 데이터 갱신되지 않았다면 304 Not Modified + 헤더 메타 정보만 응답한다.   
  (바디는 미포함)
* 클라이언트는 서버가 보낸 응답 헤더 정버로 캐시의 메타 정보를 갱신한다.   
  즉 캐시에 저장되어 있는 데이터 재활용
* 네트워크 다운로드가 발생하지만 Body는 제외한 적은 헤더 정보만 다운로드
* 대부분의 웹 브라우저의 메커니즘

> 브라우저 Network에서 상태코드 색깔이 연한것은 캐시에서 불러온것이다.

<br>

## |3. 검증 헤더와 조건부 요청2|
* **검증 해더**
  * 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
  * Last-Modified, ETag (이를 활용해 클라이언트에서 서버로 요청할 때 조건부 요청 헤더를 만들어 보내면 된다.)
* **조건부 요청 헤더**
  * 검증 헤더로 조건에 따른 분기
  * If-Modified-Since: Last-Modified 사용
  * If-None-Match: ETag 사용
  * 조건이 만족하면 200 OK
  * 조건이 만족하지 않으면 304 Not Modified

### 예시
* If-Modified-Since: 이후에 데이터가 수정되었으면?
  * **데이터 미변경 시**
    * 캐시와 서버의 최종 변경 시간이 동일하다면
    * **304 Not Modified**, 헤더 데이터만 전송(BODY 미포함)
    * 전송 용량 0.1M (헤더 0.1M, 바디 1.0M)
  * **데이터 변경 시**
    * 캐시와 서버의 최종 변경 시간이 다르다면
    * **200 OK**, 모든 데이터 전송(BODY 포함)
    * 전송 용량 1.1M

### Last-Modified, If-Modified-Since 단점
* 1초 미만 단위 캐시 조정 불가
* 날짜 기반의 로직
* 데이터 수정해 날짜가 다르지만, A -> B -> A로 수정한 경우 데이터는 동일하지만 날짜는 갱신됨   
  (원본과 캐시가 동일하지만, 날짜로 판별하므로 전체 전부 다운로드함)
* 서버에서 별도의 캐시 로직을 관리하고 싶다면   
  (스페이스, 주석처럼 영향이 없는 변경에서 캐시 유지 원한다면)

### ETag의 사용(Entity Tag), If-None-Match
* 캐시용 데이터에 임의의 고한 버전 이름을 닮   
  (ETag: "v1.0", ETag: "a2jiodwjekjl3")
* 데이터가 변경되면 이 이름을 바꿔서 변경함 (Hash를 다시 생성)   
  (Hash는 파일의 컨텐츠가 동일하다면 똑같은 Hash값이 나온다 -> A - B - A 수정인 경우 원본 받을 수 있음)
  * 예) ETag: "aaaa" -> ETag: "bbbbb"
* 단순히 ETag만 보내서 같으면 유지, 다르면 다시 다운로드

### 검증 헤더 추가
첫 번째 요청
1. 클라이언트가 요청하면 서버는 ETag값을 응답에 포함한다. 클라이언트는 응답 결과를 캐시에 저장한다.

두 번째 요청
1. cache-control의 시간 초과 이후 클라이언트가 재 요청을 한다면 캐시가 가지고 있는, ETag가 있다면   
   클라이언트는 **If-None-Match: [ETag값]**을 같이 요청에 보내 수정 됐는지 물어봄
2. 서버에서 매치가 된다면 실패이므로 **304 Not Modified**를 보낸다. (바디 제외로 보냄)
3. 클라이언트는 응답 결과를 재사용하고, 헤더 데이터를 갱신한 후 기존의 캐시를 재사용한다.

### 정리 ETag, If-None-Match 정리
* 단순히 ETag만 서버에 보내 같으면 유지, 다르면 새로 받기
* **캐시 제어 로직을 서버에서 완전히 관리한다.**
* 클라이언트는 단순히 이 값을 서버에 제공한다.(클라이언트는 캐시 메커니즘 모름)

<br>

## |4. 캐시와 조건부 요청 헤더|
### 캐시 제어 헤더
* Cache-Control: 캐시 제어
* Pragma: 캐시 제어(하위 호환)
* Expires: 캐시 유효 기간(하위 호환)

### Cache-Control : 캐시 지시어(directives)
* Cache-Control: max-age
  * 캐시 유효 시간, 초 단위
* Cache-Control: no-cache
  * 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용(조건부 요청을 통해)
  > 중간에 캐시 프록시 서버같은것이 있다. 이를 피하고 원서버에서 검증하고 사용해야한다.
* Cache-Control: no-store
  * 데이터에 민감한 정보가 있으므로 저장하면 안됨   
    (메모리에서 사용하고 최대한 빨리 삭제)

### Pragma : 캐시 제어(하위 호환)
* Pragma: no-cache (동일 동작)
* HTTP 1.0 하위 호환

### Expires : 캐시 만료일 지정(하위 호환)
* expires: [특정 날짜 지정]
* 정확한 날짜로 지정
* HTTP 1.0 부터 사용
* 지금은 더 유연한 Cache-Control: max-age 권장 (함께 사용되면 Expires 무시 됨)

### 검증 헤더와 조건부 요청 헤더
* 검증 헤더(Validator)
  * **ETag**, **Last-Modified**
* 조건부 요청 헤더
  * If-Match, If-None-Match: ETag 값 사용
  * If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용

<br>

## |5. 프록시 캐시|
Origin 서버: 진짜 서버, 한국에 있는 클라이언트가 미국 서버에 접근한다면 실제 어플리케이션에서   
이미지가 있는 서버를 Origin 서버라고 한다.
* 한국 - 미국이라면 시간이 굉장히 오래 걸림
### 프록시 캐시 서버 도입
* 미국의 원 서버가 아닌 한국 어딘가에 프록시 캐시 서버를 넣어놓고, 요청이 오면   
  Origin서버를 직접 접근하는 것이 아닌 웹 브라우저가 프록시 캐시 서버를 접근하도록 한다.
* 최초 유저는 느리지만, 한 번 다운로드 받으면 두 번째 유저부터는 빠른 경우
* 내 로컬에 저장되는 캐시는 **private 캐시**, 프록시 캐시 서버 같이 공용적으로 저장되면   
  **public 캐시**라고 한다.

### Cache-Control : 캐시 지시어(directives) - 기타
* **Cache-Control: public**
  * 응답이 public 캐시(프록시 캐시 서버)에 저장되어도 된다.
* **Cache-Control: private**
  * 응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야하 함(기본값)
* Cache-Control: s-maxage
  * 프록시 캐시에만 적용되는 max-age
* Age: 60 (HTTP 헤더)
  * 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)

<br>

## |6. 캐시 무효화|
### Cache-Control의 확실한 캐시 무효화 응답
> 웹 브라우저는 캐시를 적용하지 않아도 임의로 캐시를 해버리기도 한다.   
> 따라서 정말 캐시가 되면 안되면 아래의 항목을 모두 넣어야 한다.
* Cache-Control: no-cache, no-store, must-revalidate
* Pragma: no-cache
  * HTTP 1.0 하위 호환(혹시 과거 브라우저 존재시 무효화를 위해)

### 캐시 지시어(directives) - 확실한 캐시 무효화
* **Cache-Control: no-cache**
  * 데이터는 캐시해도 됨, 항상 **원 서버에 검증**하고 사용
* Cache-Control: no-store
  * 데이터 민감한 정보있으므로 저장하면 안됨   
    (메모리에서 사용하고 최대한 빨리 삭제)
* **Cache-Control: must-revalidate**
  * 캐시 만료후 최초 조회시 **원 서버에 검증**해야함
  * 원 서버 접근 실패시 반드시 오류가 발생해야함 - 504(Gateway Timeout)
  * must-revalidate는 캐시 유효 시간이라면 캐시를 사용함
* **Pragma: no-cache**
  * HTTP 1.0과 하위호환

### no-cache vs must-revalidate
1. no-cache 기본 동작
   1. 캐시 서버 요청 (no-cache + ETag : 프록시 캐시 서버로)
   2. 원 서버 요청 (no-cache + ETag : 원 서버로 넘김)
   3. 원 서버 검증
   4. 원 서버 응답 (304 Not Modified)
   5. 프록시 캐시 서버 응답 (304 Not Modified)
   6. 브라우저 캐시에서 캐시 데이터 사용
   > 만약에 프록시 캐시 서버가 원 서버에 요청하려고 할 때 원 서버에 접근할 수 없는 경우   
   > 캐시 서버 설정에 따라 오래된 캐시 데이터를 반환할 수 있음 (Error 혹은 200 OK)   
   > **이런 상황을 막기 위해 must-revalidate 사용함**
2. must-revalidate
   1. 위와같은 상황에서 원 서버에 접근할 수 없는 경우, 항상 오류가 발생해야함   
      (504 Gateway Timeout)