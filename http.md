## [인터넷 네트워크 : IP(인터넷 프로토콜)]

* IP(인터넷 프로토콜) 역할
  * 지정한 IP 주소에 데이터 전살
  * 패킷(Packet)이라는 통신 단위로 데이터 전달

* IP 패킷 정보   
  * [클라이언트]
  * 전송데이터 외에 출발지IP, 목적지IP 및 메시지를 적어야 한다.
  * 이후 클라이언트는 패킷을 인터넷 망에 던진다.
  * 서로 노드끼리도 패킷 규약을 지키므로 결국 서버측으로 보내짐
  * [서버]
  * 출발지를 자신 목적지를 방금 받은 패킷의 IP, 내용은 잘 받았다는 내용으로 다시 클라이언트에게 보낸다.
* 요청, 응답시에 서로 다른 인터넷망으로 전달 될 수 도 있다.(하지만 목적지는 동일함)
* 하지만 이러한 IP 프로토콜 방식은 한계가 있다.
  * **비연결성**
    * 패킷 받을 대상 없고, 서비스 불능 상태여도 패킷 전송
  * **비신뢰성**
    * 중간에 패킷이 사라지면?
    * 패킷이 순서대로 안오면?(노드 장애, 다중 결로 라우팅과 같이 중간에 유실되거나 지연도착으로 인해 순서가 변경)
  * **프로그램 구분**
    * 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상 일 경우

> 이런 문제를 해결하는 방법이 TCP와 UDP가 있다.

<br><br>

## [인터넷 네트워크 : TCP, UDP]
* 인터넷 프로토콜 스택의 4계층
   
|인터넷 프로토콜 스택의 4계층|
|---------------------------|
|애플리케이션 계층 - HTTP, FTP|
|전송 계층 - TCP, UDP|
|인터넷 계층 - IP|
|네트워크 인터페이스 계층|

* TCP, UDP는 IP라는것에 위에 살짝 얹어서 보완해준다고 생각 좀 더 직관적으로

|||
|-|-|
|**애플리케이션**: |웹 브라우저, 네트워크 게임, 채팅 프로그램|
||[SOCKET 라이브러리]|
|**OS**: |[TCP] [UDP]]|
||IP(Internet Protocol|
|**네트워크 인터페이스**: |[LAN 드라이버, LAN 장비], LAN카드|

LAN 카드가 ---> 인터넷에 연결되고 ----> 서버로 보내짐

**[전송 순서]**   
1. 프로그램이 특정 메시지 생성
2. SOCKET 라이브러리를 통해 전달 (어플리케이션 계층)
3. TCP 정보 생성(패킷), 메시지 데이터 포함 (OS계층)
4. IP 패킷 생성, TCP 데이터 포함 (OS계층)
5. 이후 네트워크 인터페이스를 통해 LAN카드로 나감(이때 이더넷 프레임으로 감싸서 나가짐)

**[IP 패킷 정보]** :출발지 IP, 목적지 IP, 기타   
**[TCP/IP 패킷 정보]** : 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보   
<br>

### **[TCP의 특징]**   
전송 제어 프로토콜 (전송을 어떻게 할지 제어함)
* 연결지향 - TCP 3 way handshake(가상연결) : 연결을 하고 메시지를 보낸다.
* 데이터 전달 보증 : 패킷이 중간에 누락되면 보낸 클라이언트가 알 수 있음
* 순서 보장
> 따라서 TCP는 신뢰할 수 있고 대부분 TCP를 사용한다.

<br>

**TCP의 특징1 : TCP 3 way handshake**
1. SYN : 클라이언트에서 서버로 접속 요청 보냄
2. SYN + ACK(요청수락) : 서버도 수락과 동시에 클라이언트에 접속 요청을 보낸다.
3. ACK : 클라이언트는 요청을 수락한다. 
4. 이렇게 연결이 되고난 후 데이터가 전송된다.  
> ACK와 함꼐 메시지 전송 가능   
> 이렇게 하면 클라이언트와 서버가 서로를 믿을 수 있다.   
> 하지만 위 연결은 진짜로 연결된 것이 아니다.(개념적 연결)   
> 내부 서버들이 진짜로 연결됐는지는 모르고 서버와 클라이언트만 서로 연결됐다고 생각(논리적)

<br>   

**TCP의 특징2 : 데이터 전달 보증**
* TCP가 붙게 되면 서버로 데이터가 전송되면 데이터를 잘 받았다고 클라이언트로 메시지를 다시 보내줌

<br>

**TCP의 특징3 : 순서 보장**
1. 만약 패킷1, 패킷2, 패킷3 순서로 전송했을때
2. 서버에 패킷1, 패킷3, 패킷2 순서로 도착
3. 서버는 클라이언트에게 패킷2부터 다시 보내라고 클라이언트에 요청함

<br>

**이렇게 TCP의 특징들이 전부 가능한 이유는 TCP데이터 안에 전송제어, 순서, 검증 정보들이 포함되어 있기 때문이다. 따라서 TCP를 신뢰할 수 있는 프로토콜이라 말함**

<br>

### **[UDP의 특징]**   
사용자 데이터그램 프로토콜

* 하얀 도화지에 비유 (기능 거의 없음)
* 연결지향 - TCP 3 way handshake, 데이터 전달, 순서 보증 지원 안됨 따라서 단순하고 빠름
* IP와 거의 같지만 **PORT** 체크섬(메시지에 대해 올바른지 검증) 정도만 추가됨
> **PORT:** 하나의 IP에서 여러 애플리케이션을 이용할 때 여러 패킷이 이용되는데 이 때 각 패킷이 어떤 애플리케이션에서 이용되는 패킷인지 구분해주는 역할을 한다.   
> **UDP는 왜 쓸까?** : TCP는 3 way hs에서 시간이 많이 소요되고, 각종 데이터들의 양이 크므로 전송속도를 증가시키기 어렵다 이미 인터넷이 TCP기반이라 손을 댈 수 없다.   
> 따라서 더 최적화 하고 싶으면 TCP는 그대로 두고 UDP를 이용   
> UDP는 아무것도 없기 때문에 원하는것을 애플리케이션 레벨에서 만들면 된다. (요즘 각광 받음)

<br><br>

## [인터넷 네트워크 : PORT]
* 만약 한번에 둘 이상 연결해야 한다면 (게임, 화상통화, 웹 브라우저) 클라이언트 PC가 여러개의 서버와 통신해야 함
* 이때 각 서버에서 패킷들이 클라이언트로 날라오는데 어디에서 필요한 패킷인지 구분하기 힘듦
* TCP/IP 패킷 정보에는 출발지 PORT, 목적지 PORT가 존재한다.
  * **IP** : 목적지 서버를 찾거나, 출발지 클라이언트를 찾기 위함
  * **PORT** : 클라이언트 서버안에서 돌아가는 애플리케이션을 구분하기 위함
* 따라서 같은 IP내에서 프로세스를 구분하는것이 포트가 된다.
* 출발지 PORT, 목적지 PORT가 TCP 패킷에 존재하므로 서버로 요청할 때는 목적지 PORT를 이용하고,   
  반대로 서버에서 응답이 올때는 출발지 PORT를 이용해 응답이 온다.
  |웹 브라우저 요청 예시|출발지|목적지|
  |-|-|-|
  |IP|100.100.100.1|200.200.200.2|
  |PORT|10010|80|
  > 위와 같이 있을 때 브라우저 요청은 200.200.200.2:80으로 요청한다.   
  > 서버측은 브라우저를 100.100.100.1:10010으로 응답해 띄워준다.   
  > IP는 아파트 PORT는 몇동 몇호

<br><br>

## [인터넷 네트워크 : DNS]
* IP는 기억하기 어렵다는 문제가 있고, 변경될 수 있다.
  * 변경이 되면 접근을 할 수 없다.
* 따라서 DNS 도메인 네임 시스템을 이용한다.
  * 중간에 전화번호부 같은 서버를 제공한다.
  * 즉 도메인 명을 IP 주소로 변환한다.

  DNS 서버
  |도메인 명| IP|
  |-|-|
  |google.com|200.200.200.2|
  |aaa.com|210.210.210.3|
  > 이렇게 DNS 서버가 있을떄 어떻게 사용할까?   
  > 1. 클라이언트가 도메인 명으로 요청
  > 2. DNS서버가 응답으로 IP를 알려줌
  > 3. 받은 IP로 클라이언트는 서버로 접속한다.